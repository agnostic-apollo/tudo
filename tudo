#!/data/data/com.termux/files/usr/bin/bash

#title:         tudo
#description:   a wrapper script to drop to the supported shells or
#               execute shell script files or their text passed as
#               an argument with termux user context in termux
#author:        agnostic-apollo
#usage:         run "tudo --help" for detailed list of usages
#date:          14-Dec-2020
#bash version:  4.1 or higher
#credits:       -
version=0.2.0



### Install Instructions For Termux In Android:

#The `tudo` file should be placed in termux `bin` directory `/data/data/com.termux/files/usr/bin`.  
#It should have `termux` `uid:gid` ownership and have executable `700` permission before it can be run directly without `bash`.  
#
#1. Download the `tudo` file.  
#
#    - Download to termux bin directory directly from github using `curl` using a non-root termux shell.  
#        Run `pkg install curl` to install `curl` first.  
#        - Latest release:  
#
#          `curl -L 'https://github.com/agnostic-apollo/tudo/releases/latest/download/tudo' -o "/data/data/com.termux/files/usr/bin/tudo"`  
#
#        - Specific release:  
#
#          `curl -L 'https://github.com/agnostic-apollo/tudo/releases/download/v0.1.0/tudo' -o "/data/data/com.termux/files/usr/bin/tudo"`  
#
#        - Master Branch *may be unstable*:  
#
#          `curl -L 'https://github.com/agnostic-apollo/tudo/raw/master/tudo' -o "/data/data/com.termux/files/usr/bin/tudo"`  
#
#    - Download `tudo` file manually from github to the android download directory and then copy it to termux bin directory.  
#
#      You can download the `tudo` file from a github release from the `Assets` dropdown menu.  
#
#      You can also download it from a specific github branch/tag by opening the `tudo` file from the `Code` section.  
#      Right-click or hold the `Raw` button at the top and select `Download/Save link`.  
#
#      Then copy the file to termux bin directory using `cat` command below or use a root file browser to manually place it.  
#
#       `cat "/storage/emulated/0/Download/tudo" > "/data/data/com.termux/files/usr/bin/tudo"`  
#
#2. Set `termux` ownership and executable permissions.  
#
#    - If you used a `curl` or `cat` to copy the file, then use a non-root termux shell to set ownership and permissions with `chown` and `chmod` commands respectively:  
#
#      `export termux_bin_path="/data/data/com.termux/files/usr/bin"; export owner="$(stat -c "%u" "$termux_bin_path")"; chown "$owner:$owner" "$termux_bin_path/tudo" && chmod 700 "$termux_bin_path/tudo";`  
#
#    - If you used a root file browser to copy the file, then use `su` to start a root shell to set ownership and permissions with `chown` and `chmod` commands respectively:  
#
#      `export termux_bin_path="/data/data/com.termux/files/usr/bin"; export owner="$(stat -c "%u" "$termux_bin_path")"; su -c "chown \"$owner:$owner\" \"$termux_bin_path/tudo\" && chmod 700 \"$termux_bin_path/tudo\"";`  
#
#    - Or manually set them with your root file browser. You can find `termux` `uid` and `gid` by running the command `id -u` in a non-root termux shell or by checking the properties of the termux `bin` directory from your root file browser.  
#

tudo_set_default_variables() {

#set termux and android default variables
TERMUX_FILES="/data/data/com.termux/files"
TERMUX_HOME_BASENAME="home"
TERMUX_HOME="$TERMUX_FILES/$TERMUX_HOME_BASENAME"
TERMUX_PREFIX_BASENAME="usr"
TERMUX_PREFIX="$TERMUX_FILES/$TERMUX_PREFIX_BASENAME"
TERMUX_BIN="$TERMUX_PREFIX/bin"
TERMUX_BIN_APPLETS="$TERMUX_PREFIX/bin/applets"
TERMUX_PATH="$TERMUX_BIN:$TERMUX_BIN_APPLETS"
TERMUX_LD_LIBRARY_PATH="$TERMUX_PREFIX/lib"
TMPDIR="$TERMUX_PREFIX/tmp"
SYS_XBIN="/system/xbin"
SYS_BIN="/system/bin"
ANDROID_PATH="$SYS_XBIN:$SYS_BIN"
ANDROID_OTHER_BIN_PATHS="/sbin:/vendor/bin:/system/sbin"
BASH_SHELL_PATH="$TERMUX_BIN/bash"
TERM="xterm-256color"

#termux is currently an english-only environment
LANG="en_US.UTF-8"


### Set User Modifiable Variables Start
### It is highly advisable to use the tudo.config file instead to modify the default values

#set TUDO_SHELL_HOME which will be used as tudo shell home directory
[ ! -z "$TUDO_SHELL_HOME" ] && custom_tudo_shell_home_set=1
TUDO_SHELL_HOME="${TUDO_SHELL_HOME:=$TERMUX_HOME}" #default to '$TERMUX_HOME'

#set TUDO_POST_SHELL_HOME which will be used as tudo post shell home directory
[ ! -z "$TUDO_POST_SHELL_HOME" ] && custom_tudo_post_shell_home_set=1
TUDO_POST_SHELL_HOME="${TUDO_POST_SHELL_HOME:=$TERMUX_HOME}" #default to '$TERMUX_HOME'

#set the prompt string 1 for the tudo shell
TUDO_SHELL_PS1="${TUDO_SHELL_PS1:=Ⲧ }" #default to "Ⲧ " #U+2CA6, &#x2CA6;, coptic capital letter tau

#set the prompt string 1 for the tudo post shell
TUDO_POST_SHELL_PS1="${TUDO_POST_SHELL_PS1:=Ⲧ }" #default to "Ⲧ " #U+2CA6, &#x2CA6;, coptic capital letter tau

#set any additional paths you want to export other than termux bin, android bin and su bin paths,
#separated with colons `:`
#the string must not start or end with or contain two consecutive colons ':'
#the `--export-paths` option will override this value
ADDITIONAL_PATHS_TO_EXPORT="${ADDITIONAL_PATHS_TO_EXPORT:=}" #default to none

#set to "1" or pass "-L" as argument if you want to automatically export all the paths that already exist
#in the PATH variable at the moment the tudo command is run
#the default paths mentioned above and any path in ADDITIONAL_PATHS_TO_EXPORT are always exported
export_all_existing_paths_in_path_variable="${export_all_existing_paths_in_path_variable:=0}" #default to 0

#set any additional ld library paths you want to export other than termux lib and android lib paths,
#separated with colons `:`
#the string must not start or end with or contain two consecutive colons ':'
#the `--export-ld-lib-paths` option will override this value
ADDITIONAL_LD_LIBRARY_PATHS_TO_EXPORT="${ADDITIONAL_LD_LIBRARY_PATHS_TO_EXPORT:=}" #default to none

#set to "1" or pass "-P" as argument if you want to automatically export all the paths that already exist
#in the LD_LIBRARY_PATH variable at the moment the tudo command is run
#the default paths mentioned above and any path in ADDITIONAL_LD_LIBRARY_PATHS_TO_EXPORT are always exported
export_all_existing_paths_in_ld_library_path_variable="${export_all_existing_paths_in_ld_library_path_variable:=0}" #default to 0

#set to 1 if you want to automatically create rc files for interactive shells, otherwise 0
tudo_shells_automatically_create_rc_files="${tudo_shells_automatically_create_rc_files:=1}" #default to 1

#set to 1 if you want to automatically create history files for interactive shells, otherwise 0
tudo_shells_automatically_create_history_files="${tudo_shells_automatically_create_history_files:=1}" #default to 1

#set to 1 if you want to store command history for interactive shells, otherwise 0
tudo_shells_history_enabled="${tudo_shells_history_enabled:=1}" #default to 1

#set to "1" if you want to share rc files and history files between normal termux shell
#and tudo shell if TUDO_SHELL_HOME is same as TERMUX_HOME
tudo_shell_share_rcfiles_and_histfiles="${tudo_shell_share_rcfiles_and_histfiles:=1}" #default to 1

#set to "1" if you want to share rc files and history files between normal termux shell
#and tudo post shell if TUDO_POST_SHELL_HOME is same as TERMUX_HOME
tudo_post_shell_share_rcfiles_and_histfiles="${tudo_post_shell_share_rcfiles_and_histfiles:=1}" #default to 1

#set to 1 if you want to add path for the su binary to the $PATH_TO_EXPORT, otherwise 0
add_su_bin_path_to_path_variable="${add_su_bin_path_to_path_variable:=1}" #default to 1


#for f in TUDO_SHELL_HOME TUDO_POST_SHELL_HOME TUDO_SHELL_PS1 TUDO_POST_SHELL_PS1 ADDITIONAL_PATHS_TO_EXPORT export_all_existing_paths_in_path_variable ADDITIONAL_LD_LIBRARY_PATHS_TO_EXPORT export_all_existing_paths_in_ld_library_path_variable tudo_shells_automatically_create_rc_files tudo_shells_automatically_create_history_files tudo_shells_history_enabled tudo_shell_share_rcfiles_and_histfiles tudo_post_shell_share_rcfiles_and_histfiles add_su_bin_path_to_path_variable; do echo "$f=\`${!f}\`"; done; echo $'\n'

### Set User Modifiable Variables End


### Set Default Variables Start
#The following variables must not be modified unless you know what you are doing

tudo_verbose_level=0 #default to log level 0
tudo_args_verbose_level=0 #set this to 1 manually, if you want to debug arguments received

command_type="path" #default to path
command_type_path_forced=0 #default to 0
same_tudo_post_shell_as_tudo_shell=0 #default to 0
same_tudo_post_shell_home_as_tudo_shell_home=0 #default to 0
parse_commands_as_per_run_command_intent_rules=0 #default to 0
exec_tudo_shell=0 #default to 0
disable_stdin_for_core_script=0 #default to 0
run_core_script_in_background=0 #default to 0
exit_early_if_core_script_fails=0 #default to 0
go_back_to_last_activity_after_running_core_script=0 #default to 0
go_to_launcher_activity_after_running_core_script=0 #default to 0
clear_shell_after_running_core_script=0 #default to 0
run_interactive_post_tudo_shell_after_running_core_script=0 #default to 0
force_use_temp_script_file_for_core_script=0 #default to 0
core_script_is_path_to_script_file=0 #default to 0
decode_core_script_content=0 #default to 0
do_not_delete_tudo_temp_directory_on_exit=0 #default to 0
remove_previous_tudo_temp_files=0 #default to 0
hold_after_tudo=0 #default to 0
hold_only_on_failure=0 #default to 0
sleep_after_tudo=0 #default to 0
sleep_only_on_failure=0 #default to 0
dry_run_tudo=0 #default to 0
disable_arguments_logging=0 #default to 0
set_tudo_shell_terminal_title=0 #default to 0
force_set_priority_to_android_paths=0 #default to 0

TUDO_SHELL="" #default to none
TUDO_SHELL_BASENAME="" #default to none
TUDO_SHELL_PARENT_DIR="" #default to none
TUDO_POST_SHELL="" #default to none
TUDO_POST_SHELL_BASENAME="" #default to none
TUDO_POST_SHELL_PARENT_DIR="" #default to none
TUDO_SHELL_RCFILE="" #default to none
TUDO_POST_SHELL_RCFILE="" #default to none
TUDO_SHELL_HISTFILE="" #default to none
TUDO_POST_SHELL_HISTFILE="" #default to none
TUDO_TEMP_DIRECTORY="" #default to none
TUDO_TEMP_DIRECTORY_PREFIX=".tudo.temp"
TUDO_CORE_SCRIPT_TEMP_FILENAME="" #default to none
TUDO_CORE_SCRIPT_REDIRECT_MODE="" #default to none
TUDO_SHELL_WORKING_DIR="" #default to none
TUDO_SHELL_TERMINAL_TITLE="" #default to none
ADDITIONAL_TUDO_SHELL_PRE_COMMANDS_TO_RUN="" #default to none
ADDITIONAL_TUDO_SHELL_POST_COMMANDS_TO_RUN="" #default to none
ADDITIONAL_TUDO_POST_SHELL_PRE_COMMANDS_TO_RUN="" #default to none
ADDITIONAL_TUDO_POST_SHELL_POST_COMMANDS_TO_RUN="" #default to none
TUDO_SHELL_STDIN_STRING="" #default to none
TUDO_POST_SHELL_STDIN_STRING="" #default to none
TUDO_SUPPORTED_SHELLS="" #default to none
TUDO_SUPPORTED_POST_SHELLS="" #default to none
SLEEP_TIME_AFTER_TUDO="" #default to none
HOLD_STRING_AFTER_TUDO="" #default to none
COMMA_ALTERNATIVE="‚" #U+201A, &sbquo;, &#8218;, single low-9 quotation mark
TUDO_ARG_MAX_SAFE_LIMIT=122880 #value should be in bytes, default to 120KB

TUDO_SUPPORTED_INTERACTIVE_SHELLS="bash zsh dash sh fish python ruby pry node perl lua5.2 lua5.3 lua5.4 php python2 ksh"
TUDO_SUPPORTED_SCRIPT_SHELLS="bash zsh dash sh fish python ruby node perl lua5.2 lua5.3 lua5.4 php python2 ksh"
TUDO_SCRIPT_SHELLS_WITHOUT_PROCESS_SUBSTITUTION_SUPPORT="dash sh node php"

declare -ga TUDO_COMMAND=()
declare -ga SHELL_COMMAND=()
declare -ga SHELL_INTERACTIVE_COMMAND=()
declare -ga TUDO_SHELL_COMMAND=()
declare -ga TUDO_SHELL_INTERACTIVE_COMMAND=()
declare -ga TUDO_POST_SHELL_INTERACTIVE_COMMAND=()

declare -ga SHELL_ADDITIONAL_COMMAND_OPTIONS=()
declare -ga SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS=()
declare -ga TUDO_SHELL_ADDITIONAL_COMMAND_OPTIONS=()
declare -ga TUDO_SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS=()
declare -ga TUDO_POST_SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS=()
declare -ga TUDO_RLWRAP_ADDITIONAL_COMMAND_OPTIONS=()

#set regexes for validation
valid_absolute_path_regex='^(/[^/]+)+$'
valid_path_in_system_partition_regex='^/system/.*'
valid_path_under_termux_files_regex='^'"$TERMUX_FILES"'/.+'
valid_path_under_termux_home_regex='^'"$TERMUX_HOME"'/.+'

### Set Default Variables End

}

[[ x"${BASH_SOURCE[0]}" == x"$0" ]] && tudo_exit_command="exit" || tudo_exit_command="return"

function tudo_log() { local log_level="${1}"; shift; if [[ $tudo_verbose_level -ge $log_level ]]; then echo "$@"; fi }
function tudo_log_literal() { local log_level="${1}"; shift; if [[ $tudo_verbose_level -ge $log_level ]]; then echo -e "$@"; fi }
function tudo_log_errors() { echo "$@" 1>&2; }
function tudo_log_args() { if [[ $tudo_args_verbose_level -ge "1" ]]; then echo "$@"; fi }
function tudo_log_arg_errors() { echo "$@" 1>&2; }

#enable the following line if you want to log function runtimes with the '-vv' option
#tudo_start_time=$(date +%s%3N); function tudo_log_literal() { local log_level="${1}"; shift; if [[ $tudo_verbose_level -ge $log_level ]]; then if [[ "$*" == *"Running"* ]]; then tudo_end_time=$(date +%s%3N); run_time=$((tudo_end_time-tudo_start_time)); echo -e "Runtime $run_time\n"; tudo_start_time=$(date +%s%3N); fi; echo -e "$@"; fi }


tudo_main() {

	local return_value

	#if tudo_config_file exists, source it
	tudo_config_file="/data/data/com.termux/files/home/.config/tudo/tudo.config"
	tudo_config_file_sourced=0
	if [ -f "$tudo_config_file" ] && [ -r "$tudo_config_file" ]; then
		source "$tudo_config_file"
		tudo_config_file_sourced=1
	fi

	#set default variables
	#there are set by a function so that they do not automatically override already set variables
	#if the script is sourced
	#user modifiable variables will only be set if the tudo_config_file didn't set them or
	#if they were not already exported
	tudo_set_default_variables

	#process the command or options passed to tudo
	process_tudo_parameters "$@"

	#validate command_type
	if [ -z "$command_type" ]; then
		show_tudo_help
		return_value=0
	elif [[ "$command_type" != *,* ]] && [[ ",su,asu,path,script," == *",$command_type,"* ]]; then
		tudo_run
		return_value=$?
	else
		tudo_log_errors "Unknown command type $command_type"
		exit_tudo_on_error
	fi

	tudo_run_pre_exit_commands $return_value

	$tudo_exit_command $return_value

}

tudo_run() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo"

	#if tudo_config_file_sourced is enabled
	if [[ "$tudo_config_file_sourced" == "1" ]]; then
		tudo_log 2 "config was sourced from ~/.config/tudo/tudo.config"
	fi

	#if command_type equals "su" or "asu"
	if [[ "$command_type" == "su" ]] || [[ "$command_type" == "asu" ]]; then
		TUDO_SUPPORTED_SHELLS="$TUDO_SUPPORTED_INTERACTIVE_SHELLS"

		# The arguments passed to '--shell-options' are meant for interactive shell
		TUDO_SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS=("${TUDO_SHELL_ADDITIONAL_COMMAND_OPTIONS[@]}")
		TUDO_SHELL_ADDITIONAL_COMMAND_OPTIONS=()

		interactive_tudo_shell_required=1
	#if command_type equals "path"
	elif [[ "$command_type" == "path" ]]; then
		TUDO_SUPPORTED_SHELLS="bash"

		#unset TUDO_SHELL so that it defaults to bash in tudo_set_tudo_shell
		TUDO_SHELL=""

		#ignore any shell options that are passed
		TUDO_SHELL_ADDITIONAL_COMMAND_OPTIONS=()

		interactive_tudo_shell_required=0
	#if command_type equals "script"
	elif [[ "$command_type" == "script" ]]; then
		TUDO_SUPPORTED_SHELLS="$TUDO_SUPPORTED_SCRIPT_SHELLS"
		TUDO_SUPPORTED_POST_SHELLS="$TUDO_SUPPORTED_INTERACTIVE_SHELLS"

		interactive_tudo_shell_required=0
	else
		tudo_log_errors "command_type \"$command_type\" not handled while running tudo command in \"tudo_run\""
		return 1
	fi

	#if command_type equals "script"
	if [[ "$command_type" == "script" ]]; then
		#if disable_stdin_for_core_script is enabled or stdin is not available while running this script
		#force enable disable_stdin_for_core_script
		if [[ "$disable_stdin_for_core_script" == "1" ]] || [ ! -t 0 ]; then
			disable_stdin_for_core_script=1
		else
			disable_stdin_for_core_script=0
		fi
	fi


	#if run_interactive_post_tudo_shell_after_running_core_script is enabled and command_type equals "script"
	if [[ "$run_interactive_post_tudo_shell_after_running_core_script" == "1" ]] && [[ "$command_type" == "script" ]]; then
		#if same_tudo_post_shell_home_as_tudo_shell_home is enabled
		if [[ "$same_tudo_post_shell_home_as_tudo_shell_home" == "1" ]]; then
			#override TUDO_POST_SHELL_HOME
			TUDO_POST_SHELL_HOME="$TUDO_SHELL_HOME"
		fi
	else
		#unset TUDO_POST_SHELL_HOME so that TUDO_POST_SHELL variables are not set
		TUDO_POST_SHELL_HOME=""
	fi


	#test if bash shell executable file exists at BASH_SHELL_PATH
	#this is to ensure that bash shell is always the default shell if '--shell` and '--post-shell' options are not passed
	#and the shell is automatically validated so that it doesn't have to again in tudo_set_tudo_shell and tudo_set_tudo_post_shell
	#bash shell is also needed by the 'su --shell' command
	#tudo_run_file_type_tests_on_path label path log_file_tests_failure_errors show_stat_output_on_file_tests_failure check_if_absolute_path file_type_tests
	tudo_run_file_type_tests_on_path "BASH_SHELL_PATH" "$BASH_SHELL_PATH" 1 1 1 "frx" || return $?

	#if disable_stdin_for_core_script is enabled
	if [[ "$add_su_bin_path_to_path_variable" == "1" ]]; then
		#set SU and SU_BIN_PATH
		tudo_set_su_variables || return $?
	fi

	#set required variables to be used by this script
	tudo_set_required_variables || return $?

	#set priority_dependent_variables with termux priority
	tudo_set_priority_dependent_variables "termux" || return $?



	#set TUDO_SHELL and TUDO_SHELL_BASENAME
	tudo_set_tudo_shell || return $?

	#if command_type does not equal "path"
	#command_type "path" does not use an interactive shell so no need to set these
	if [[ "$command_type" != "path" ]]; then
		#set TUDO_SHELL_RCFILE and TUDO_SHELL_RCFILE_VALUE to be sourced when TUDO_SHELL is run
		tudo_set_tudo_shell_rcfile || return $?

		#set TUDO_SHELL_HISTFILE
		tudo_set_tudo_shell_histfile || return $?
	fi

	#set TUDO_SHELL_COMMAND and TUDO_SHELL_INTERACTIVE_COMMAND command to be run
	tudo_set_tudo_shell_command || return $?



	#if TUDO_POST_SHELL_HOME is set
	if [ ! -z "$TUDO_POST_SHELL_HOME" ]; then
		#if same_tudo_post_shell_as_tudo_shell is enabled
		if [[ "$same_tudo_post_shell_as_tudo_shell" == "1" ]]; then
			#override TUDO_POST_SHELL
			TUDO_POST_SHELL="$TUDO_SHELL"
		fi

		#set TUDO_POST_SHELL and TUDO_POST_SHELL_BASENAME
		tudo_set_tudo_post_shell || return $?

		#set TUDO_POST_SHELL_RCFILE and TUDO_POST_SHELL_RCFILE_VALUE to be sourced when TUDO_POST_SHELL is run
		tudo_set_tudo_post_shell_rcfile || return $?

		#set TUDO_POST_SHELL_HISTFILE file
		tudo_set_tudo_post_shell_histfile || return $?

		#set TUDO_POST_SHELL_INTERACTIVE_COMMAND command to be run
		tudo_set_tudo_post_shell_command || return $?
	fi



	#if command_type equals "path"
	if [[ "$command_type" == "path" ]]; then
		#set TUDO_PATH_COMMAND
		tudo_set_tudo_command_path || return $?
	fi



	#set PRE_TUDO_SHELL_COMMANDS_TO_RUN
	tudo_set_pre_tudo_shell_commands_to_run || return $?

	#if TUDO_POST_SHELL_HOME is set
	if [ ! -z "$TUDO_POST_SHELL_HOME" ]; then
		#set PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN
		tudo_set_pre_tudo_post_shell_commands_to_run || return $?
	fi



	#set traps to run commands before exiting tudo
	set_tudo_traps || return $?



	#if dry_run_tudo is not enabled
	if [[ "$dry_run_tudo" != "1" ]]; then
		#create TUDO_SHELL_HOME, TUDO_SHELL_RCFILE, TUDO_SHELL_HISTFILE and/or
		#TUDO_POST_SHELL_HOME, TUDO_POST_SHELL_RCFILE, TUDO_POST_SHELL_HISTFILE
		#and TUDO_SHELL_WORKING_DIR if missing
		tudo_setup_tudo_shell_home_and_working_environment || return $?
	fi



	#run tudo command depending on command type

	local TUDO_EXIT_CODE=0

	BASH_SHELL_COMMAND=("$BASH_SHELL_PATH" "--noprofile" "--norc")

	#if command_type equals "su" or "asu"
	if [[ "$command_type" == "su" ]] || [[ "$command_type" == "asu" ]]; then

		#if TUDO_SHELL_INTERACTIVE_COMMAND is not set
		if [ ${#TUDO_SHELL_INTERACTIVE_COMMAND[@]} -eq 0 ]; then
			tudo_log_errors "TUDO_SHELL_INTERACTIVE_COMMAND is not set while running tudo $command_type command in \"tudo_run\""
			return 1
		fi

		#if exec_tudo_shell is enabled, then prepend "exec"
		if [[ "$exec_tudo_shell" == "1" ]]; then
			BASH_SHELL_COMMAND=("exec" "${BASH_SHELL_COMMAND[@]}")
		fi

		#set TUDO_COMMAND_TO_RUN to run PRE_TUDO_SHELL_COMMANDS_TO_RUN and then
		#start an interactive TUDO_SHELL
		TUDO_COMMAND_TO_RUN="$PRE_TUDO_SHELL_COMMANDS_TO_RUN"
		printf -v "TUDO_SHELL_INTERACTIVE_COMMAND_STRING" "$TUDO_SHELL_INTERACTIVE_COMMAND_PRINT_FORMAT" "${TUDO_SHELL_INTERACTIVE_COMMAND[@]}"
		TUDO_COMMAND_TO_RUN+="$TUDO_SHELL_INTERACTIVE_COMMAND_STRING"

		#if TUDO_SHELL_STDIN_STRING is set
		if [ ! -z "$TUDO_SHELL_STDIN_STRING" ]; then
			#if TUDO_SHELL_BASENAME is in TUDO_SCRIPT_SHELLS_WITHOUT_PROCESS_SUBSTITUTION_SUPPORT
			if [[ " $TUDO_SCRIPT_SHELLS_WITHOUT_PROCESS_SUBSTITUTION_SUPPORT " == *" $TUDO_SHELL_BASENAME "* ]]; then
				#pass TUDO_SHELL_STDIN_STRING as stdin with a herestring to TUDO_SHELL
				TUDO_COMMAND_TO_RUN+=' <<<'"'${TUDO_SHELL_STDIN_STRING//\'/\'\\\'\'}'"
			else
				#pass TUDO_SHELL_STDIN_STRING as stdin with process substitution to TUDO_SHELL
				TUDO_COMMAND_TO_RUN+=' < <(printf "%s" '"'${TUDO_SHELL_STDIN_STRING//\'/\'\\\'\'}'"')'
			fi
		fi


		tudo_log_literal 2 "\n\n\nRunning tudo $command_type commmand"
		tudo_log 1 $'\n'"BASH_SHELL_COMMAND=\`${BASH_SHELL_COMMAND[*]}\`"
		tudo_log 1 $'\n'"TUDO_COMMAND_TO_RUN=\`$TUDO_COMMAND_TO_RUN\`"

		#if dry_run_tudo is not enabled
		if [[ "$dry_run_tudo" != "1" ]]; then
			#run TUDO_COMMAND_TO_RUN
			"${BASH_SHELL_COMMAND[@]}" <(printf "%s" "$TUDO_COMMAND_TO_RUN")
			TUDO_EXIT_CODE=$?
		fi


	#if command_type equals "path"
	elif [[ "$command_type" == "path" ]]; then

		#set script to run in TUDO_PATH_COMMAND_TO_RUN
		tudo_set_tudo_path_command || return $?

		#if exec_tudo_shell is enabled, then prepend "exec"
		if [[ "$exec_tudo_shell" == "1" ]]; then
			BASH_SHELL_COMMAND=("exec" "${BASH_SHELL_COMMAND[@]}")
		fi

		#set TUDO_COMMAND_TO_RUN to run PRE_TUDO_SHELL_COMMANDS_TO_RUN and then
		#run the TUDO_PATH_COMMAND_TO_RUN
		TUDO_COMMAND_TO_RUN="$PRE_TUDO_SHELL_COMMANDS_TO_RUN$TUDO_PATH_COMMAND_TO_RUN"


		tudo_log_literal 2 "\n\n\nRunning tudo $command_type commmand"
		tudo_log 1 $'\n'"BASH_SHELL_COMMAND=\`${BASH_SHELL_COMMAND[*]}\`"

		#if disable_arguments_logging is not enabled
		if [[ "$disable_arguments_logging" != "1" ]]; then
			tudo_log 1 $'\n'"TUDO_COMMAND_TO_RUN=\`$TUDO_COMMAND_TO_RUN\`"
		fi

		#if dry_run_tudo is not enabled
		if [[ "$dry_run_tudo" != "1" ]]; then
			#run TUDO_COMMAND_TO_RUN
			"${BASH_SHELL_COMMAND[@]}" <(printf "%s" "$TUDO_COMMAND_TO_RUN")
			TUDO_EXIT_CODE=$?
		fi


	#if command_type equals "script"
	elif [[ "$command_type" == "script" ]]; then

		#if TUDO_SHELL_COMMAND is not set
		if [ ${#TUDO_SHELL_COMMAND[@]} -eq 0 ]; then
			tudo_log_errors "TUDO_SHELL_COMMAND is not set while running tudo $command_type command in \"tudo_run\""
			return 1
		fi

		#if run_interactive_post_tudo_shell_after_running_core_script is enabled and TUDO_POST_SHELL_INTERACTIVE_COMMAND is not set
		if [[ "$run_interactive_post_tudo_shell_after_running_core_script" == "1" ]] && [ ${#TUDO_POST_SHELL_INTERACTIVE_COMMAND[@]} -eq 0 ]; then
			tudo_log_errors "TUDO_POST_SHELL_INTERACTIVE_COMMAND is not set while running tudo $command_type command in \"tudo_run\""
			return 1
		fi

		#set script to run in TUDO_SCRIPT_COMMAND_TO_RUN
		tudo_set_tudo_script_command || return $?

		#if exec_tudo_shell is enabled, then prepend "exec"
		if [[ "$exec_tudo_shell" == "1" ]]; then
			BASH_SHELL_COMMAND=("exec" "${BASH_SHELL_COMMAND[@]}")
		fi

		#set TUDO_COMMAND_TO_RUN to run TUDO_SCRIPT_COMMAND_TO_RUN
		TUDO_COMMAND_TO_RUN="$TUDO_SCRIPT_COMMAND_TO_RUN"


		tudo_log_literal 2 "\n\n\nRunning tudo $command_type commmand"
		tudo_log 1 $'\n'"BASH_SHELL_COMMAND=\`${BASH_SHELL_COMMAND[*]}\`"

		#if disable_arguments_logging is not enabled
		if [[ "$disable_arguments_logging" != "1" ]]; then
			tudo_log 1 $'\n'"TUDO_COMMAND_TO_RUN=\`$TUDO_COMMAND_TO_RUN\`"
		fi

		#if dry_run_tudo is not enabled
		if [[ "$dry_run_tudo" != "1" ]]; then
			#run TUDO_COMMAND_TO_RUN
			"${BASH_SHELL_COMMAND[@]}" <(printf "%s" "$TUDO_COMMAND_TO_RUN")
			TUDO_EXIT_CODE=$?
		fi


	else
		tudo_log_errors "command_type \"$command_type\" not handled while running tudo command in \"tudo_run\""
		return 1
	fi

	#if dry_run_tudo is not enabled
	if [[ "$dry_run_tudo" != "1" ]]; then
		tudo_log 2 $'\n'"TUDO_EXIT_CODE=\"$TUDO_EXIT_CODE\""
	fi

	#if tudo is being run in an interactive shell, then reset terminal
	if [[ $- == *i* ]]; then
		stty sane &>/dev/null
	fi

	return $TUDO_EXIT_CODE

}

#tudo_run_pre_exit_commands exit_code
tudo_run_pre_exit_commands() {

	local return_value

	local exit_code="$1"

	#if hold_after_tudo is enabled
	if [[ "$hold_after_tudo" == "1" ]]; then
		#if hold_only_on_failure is not enabled or (hold_only_on_failure is enabled and exit_code does not equal 0)
		if [[ "$hold_only_on_failure" != "1" ]] || ([[ "$hold_only_on_failure" == "1" ]] && [[ "$exit_code" != "0" ]]); then
			#if stdin and stdout are available
			if [ -t 0 ] && [ -t 1 ]; then
				#if HOLD_STRING_AFTER_TUDO is set
				if [ ! -z "$HOLD_STRING_AFTER_TUDO" ]; then
					local valid_alphanumeric_and_punct_string_regex='^[[:alnum:][:punct:]]+$'

					if [[ "$HOLD_STRING_AFTER_TUDO" =~ $valid_alphanumeric_and_punct_string_regex ]]; then
						#read from stdin until HOLD_STRING_AFTER_TUDO is correctly entered
						#read should never timeout because of TMOUT=0
						local exit_while=0
						while [[ $exit_while != "1" ]]; do
							TMOUT=0 read -p "Enter \"$HOLD_STRING_AFTER_TUDO\" to exit:"$'\n' input
							if [ $? -ne 0 ] || [[ "$input" == "$HOLD_STRING_AFTER_TUDO" ]]; then
								exit_while=1
							fi
						done
					else
						tudo_log_errors "HOLD_STRING_AFTER_TUDO \"$HOLD_STRING_AFTER_TUDO\" is invalid. It can only contain alphanumeric and punctuation characters"
						return 1
					fi

				#else if only '--hold' was passed
				else
					#read any character from stdin in silent mode
					#read should never timeout because of TMOUT=0
					TMOUT=0 read -s -n 1
				fi
			fi
		fi
	fi

	#if sleep_after_tudo is enabled
	if [[ "$sleep_after_tudo" == "1" ]]; then
		#if sleep_only_on_failure is not enabled or (sleep_only_on_failure is enabled and exit_code does not equal 0)
		if [[ "$sleep_only_on_failure" != "1" ]] || ([[ "$sleep_only_on_failure" == "1" ]] && [[ "$exit_code" != "0" ]]); then
			local valid_floating_point_number_regex='^[0-9]+(\.[0-9]+)?$'

			if [[ "$SLEEP_TIME_AFTER_TUDO" =~ $valid_floating_point_number_regex ]]; then
				#sleep for SLEEP_TIME_AFTER_TUDO seconds
				sleep "$SLEEP_TIME_AFTER_TUDO"
			else
				tudo_log_errors "SLEEP_TIME_AFTER_TUDO \"$SLEEP_TIME_AFTER_TUDO\" is not a valid floating point number"
				return 1
			fi
		fi
	fi

	return 0

}

tudo_set_su_variables() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_su_variables"

	SU=""
	SU_BIN_PATH=""

	local -a su_search_paths=("/su/bin/su")

	#if "/sbin" is accessible
	if [ -x "/sbin" ]; then
		su_search_paths+=("/sbin/su" "/sbin/bin/su")
	fi

	su_search_paths+=("/system/xbin/su" "/system/bin/su" "/su/xbin/su" "/magisk/.core/bin/su")

	local su

	for su in "${su_search_paths[@]}"; do
		if [ -x "$su" ]; then
			tudo_log 2 "A su binary found at \"$su\""
			SU="$su"
			SU_BIN_PATH="${su%/su}"
			break
		fi
	done

	#if SU is not set
	if [ -z "$SU" ]; then
		tudo_log 2 "No su binary found"
	else
		tudo_log 2 "SU=\"$SU\""
		tudo_log 2 "SU_BIN_PATH=\"$SU_BIN_PATH\""
	fi

	return 0

}

tudo_set_required_variables() {

	local return_value

	#do not modify unless you known what you are doing

	tudo_log_literal 2 "\nRunning tudo_set_required_variables"

	#set LD_PRELOAD
	export LD_PRELOAD="$TERMUX_PREFIX/lib/libtermux-exec.so"

	local remove_duplicates_in_path_variable=0
	local remove_duplicates_in_ld_library_path_variable=0

	#store PATH and LD_LIBRARY_PATH
	OLD_PATH="$PATH"
	OLD_LD_LIBRARY_PATH="$LD_LIBRARY_PATH"


	#set PATH
	PATH="$TERMUX_PATH:$SYS_XBIN:$SYS_BIN"

	tudo_log 2 "PATH=\"$PATH\""

	#find machine arch
	ARCH="$(dpkg --print-architecture)"
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failed to find machine arch"
		return $return_value
	fi

	tudo_log 2 "ARCH=\"$ARCH\""

	#set LD_LIBRARY_PATH
	#if ARCH is 64 bit
	if [[ "$ARCH" == *64 ]]; then
		LD_LIBRARY_PATH="$TERMUX_LD_LIBRARY_PATH:/system/lib64:/system/lib"
	else
		LD_LIBRARY_PATH="$TERMUX_LD_LIBRARY_PATH:/system/lib"
	fi

	tudo_log 2 "LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH\""

	#set ANDROID_PATH

	#if SU_BIN_PATH is not empty, then append it to ANDROID_PATH
	if [ ! -z "$SU_BIN_PATH" ]; then
		ANDROID_PATH+=":$SU_BIN_PATH"
	fi

	#if ANDROID_OTHER_BIN_PATHS is not empty, then append it to ANDROID_PATH
	if [ ! -z "$ANDROID_OTHER_BIN_PATHS" ]; then
		ANDROID_PATH+=":$ANDROID_OTHER_BIN_PATHS"
	fi

	#set TERMUX_PRIORITY_PATH with priority to termux binary and executable paths
	TERMUX_PRIORITY_PATH="$TERMUX_PATH:$ANDROID_PATH"

	#set ANDROID_PRIORITY_PATH with priority to android binary and executable paths
	ANDROID_PRIORITY_PATH="$ANDROID_PATH:$TERMUX_PATH"

	#if export_all_existing_paths_in_path_variable is enabled and OLD_PATH is not empty, then append it to PATH variables
	if [[ "$export_all_existing_paths_in_path_variable" == "1" ]] && [ ! -z "$OLD_PATH" ]; then
		TERMUX_PRIORITY_PATH+=":$OLD_PATH"
		ANDROID_PRIORITY_PATH+=":$OLD_PATH"
		remove_duplicates_in_path_variable=1
	fi

	#if ADDITIONAL_PATHS_TO_EXPORT is not empty, then append it to PATH variables
	if [ ! -z "$ADDITIONAL_PATHS_TO_EXPORT" ]; then
		TERMUX_PRIORITY_PATH+=":$ADDITIONAL_PATHS_TO_EXPORT"
		ANDROID_PRIORITY_PATH+=":$ADDITIONAL_PATHS_TO_EXPORT"
		remove_duplicates_in_path_variable=1
	fi

	#remove_duplicates_in_path_variable is only enabled if custom paths are added to the PATH variables
	#this will reduce execution time since an external call to awk with a subshell will not be made
	#default paths set must not have any duplicates

	#remove duplicates from TERMUX_PRIORITY_PATH and check if it is valid and can be used as the PATH variable
	tudo_parse_and_validate_path_variable "TERMUX_PRIORITY_PATH" "TERMUX_PRIORITY_PATH" "$TERMUX_PRIORITY_PATH" "$remove_duplicates_in_path_variable"
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failed to parse and validate \"TERMUX_PRIORITY_PATH\""
		return $return_value
	fi

	#remove duplicates from ANDROID_PRIORITY_PATH and check if it is valid and can be used as the PATH variable
	tudo_parse_and_validate_path_variable "ANDROID_PRIORITY_PATH" "ANDROID_PRIORITY_PATH" "$ANDROID_PRIORITY_PATH" "$remove_duplicates_in_path_variable"
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failed to parse and validate \"ANDROID_PRIORITY_PATH\""
		return $return_value
	fi


	#set LD_LIBRARY_PATH_TO_EXPORT
	#if ARCH is 64 bit
	if [[ "$ARCH" == *64 ]]; then
		ANDROID_LD_LIBRARY_PATH="/system/lib64:/system/lib"
	#if ARCH is 32 bit
	else
		ANDROID_LD_LIBRARY_PATH="/system/lib"
	fi

	#set TERMUX_PRIORITY_LD_LIBRARY_PATH with priority to termux library paths
	TERMUX_PRIORITY_LD_LIBRARY_PATH="$TERMUX_LD_LIBRARY_PATH:$ANDROID_LD_LIBRARY_PATH"

	#set ANDROID_PRIORITY_LD_LIBRARY_PATH with priority to android library paths
	ANDROID_PRIORITY_LD_LIBRARY_PATH="$ANDROID_LD_LIBRARY_PATH:$TERMUX_LD_LIBRARY_PATH"

	#if export_all_existing_paths_in_ld_library_path_variable is enabled and OLD_LD_LIBRARY_PATH is not empty, then append it to LD_LIBRARY_PATH variables
	if [[ "$export_all_existing_paths_in_ld_library_path_variable" == "1" ]] && [ ! -z "$OLD_LD_LIBRARY_PATH" ]; then
		TERMUX_PRIORITY_LD_LIBRARY_PATH+=":$OLD_LD_LIBRARY_PATH"
		ANDROID_PRIORITY_LD_LIBRARY_PATH+=":$OLD_LD_LIBRARY_PATH"
		remove_duplicates_in_ld_library_path_variable=1
	fi

	#if ADDITIONAL_LD_LIBRARY_PATHS_TO_EXPORT is not empty, then append it to LD_LIBRARY_PATH variables
	if [ ! -z "$ADDITIONAL_LD_LIBRARY_PATHS_TO_EXPORT" ]; then
		TERMUX_PRIORITY_LD_LIBRARY_PATH+=":$ADDITIONAL_LD_LIBRARY_PATHS_TO_EXPORT"
		ANDROID_PRIORITY_LD_LIBRARY_PATH+=":$ADDITIONAL_LD_LIBRARY_PATHS_TO_EXPORT"
		remove_duplicates_in_ld_library_path_variable=1
	fi

	#remove_duplicates_in_path_variable is only enabled if custom paths are added to the LD_LIBRARY_PATH variables
	#this will reduce execution time since an external call to awk with a subshell will not be made
	#default paths set must not have any duplicates

	#remove duplicates from TERMUX_PRIORITY_LD_LIBRARY_PATH and check if it is valid and can be used as the LD_LIBRARY_PATH variable
	tudo_parse_and_validate_path_variable "TERMUX_PRIORITY_LD_LIBRARY_PATH" "TERMUX_PRIORITY_LD_LIBRARY_PATH" "$TERMUX_PRIORITY_LD_LIBRARY_PATH" "$remove_duplicates_in_ld_library_path_variable"
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failed to parse and validate \"TERMUX_PRIORITY_LD_LIBRARY_PATH\""
		return $return_value
	fi

	#remove duplicates from ANDROID_PRIORITY_LD_LIBRARY_PATH and check if it is valid and can be used as the LD_LIBRARY_PATH variable
	tudo_parse_and_validate_path_variable "ANDROID_PRIORITY_LD_LIBRARY_PATH" "ANDROID_PRIORITY_LD_LIBRARY_PATH" "$ANDROID_PRIORITY_LD_LIBRARY_PATH" "$remove_duplicates_in_ld_library_path_variable"
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failed to parse and validate \"ANDROID_PRIORITY_LD_LIBRARY_PATH\""
		return $return_value
	fi


	#set TERMUX_PRIORITY_LD_PRELOAD_COMMAND to set LD_PRELOAD to libtermux-exec.so
	TERMUX_PRIORITY_LD_PRELOAD_COMMAND="export LD_PRELOAD='$TERMUX_PREFIX/lib/libtermux-exec.so';"

	#set ANDROID_PRIORITY_LD_PRELOAD_COMMAND to unset LD_PRELOAD
	ANDROID_PRIORITY_LD_PRELOAD_COMMAND="unset LD_PRELOAD;"



	#set TUDO_SHELL_HOME
	tudo_trim_trailing_newlines "TUDO_SHELL_HOME" "$TUDO_SHELL_HOME"

	#replace "$PREFIX/" or "~/" prefix with termux absolute paths in TUDO_SHELL_HOME
	#canonicalize_path is only enabled if a custom path was passed for TUDO_SHELL_HOME by the user
	#this will reduce execution time since an external call to readlink with a subshell will not be made
	tudo_expand_termux_path "TUDO_SHELL_HOME" "TUDO_SHELL_HOME" "$TUDO_SHELL_HOME" "$TERMUX_PREFIX" "$TERMUX_HOME" "$custom_tudo_shell_home_set"
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failed to expand TUDO_SHELL_HOME \"$TUDO_SHELL_HOME\""
		return $return_value
	fi

	#if TUDO_SHELL_HOME is not a valid absolute path
	if [[ ! "$TUDO_SHELL_HOME" =~ $valid_absolute_path_regex ]]; then
		tudo_log_errors "The TUDO_SHELL_HOME \"$TUDO_SHELL_HOME\" is not a valid absolute path"
		return 1
	fi

	#if TUDO_SHELL_HOME is not set to an absolute path under TERMUX_FILES
	if [[ ! "$TUDO_SHELL_HOME" =~ $valid_path_under_termux_files_regex ]]; then
		tudo_log_errors "The TUDO_SHELL_HOME \"$TUDO_SHELL_HOME\" must be an absolute path under TERMUX_FILES \"$TERMUX_FILES\""
	fi

	tudo_log 2 "TUDO_SHELL_HOME=\"$TUDO_SHELL_HOME\""

	#find the parent directory of the TUDO_SHELL_HOME
	TUDO_SHELL_HOME_BASENAME="${TUDO_SHELL_HOME##*/}" #strip longest match of */ from start
	TUDO_SHELL_HOME_PARENT_DIR="${TUDO_SHELL_HOME:0:${#TUDO_SHELL_HOME} - ${#TUDO_SHELL_HOME_BASENAME}}" #substring from 0 to position of basename
	case $TUDO_SHELL_HOME_PARENT_DIR in *[!/]*/) TUDO_SHELL_HOME_PARENT_DIR=${TUDO_SHELL_HOME_PARENT_DIR%"${TUDO_SHELL_HOME_PARENT_DIR##*[!/]}"};; *[/]) TUDO_SHELL_HOME_PARENT_DIR="/";; esac #remove trailing slashes if not root

	tudo_log 2 "TUDO_SHELL_HOME_PARENT_DIR=\"$TUDO_SHELL_HOME_PARENT_DIR\""


	#if TUDO_POST_SHELL_HOME is set
	if [ ! -z "$TUDO_POST_SHELL_HOME" ]; then
		#set TUDO_POST_SHELL_HOME
		tudo_trim_trailing_newlines "TUDO_POST_SHELL_HOME" "$TUDO_POST_SHELL_HOME"

		#replace "$PREFIX/" or "~/" prefix with termux absolute paths in TUDO_POST_SHELL_HOME
		#canonicalize_path is only enabled if a custom path was passed for TUDO_POST_SHELL_HOME by the user
		#this will reduce execution time since an external call to readlink with a subshell will not be made
		tudo_expand_termux_path "TUDO_POST_SHELL_HOME" "TUDO_POST_SHELL_HOME" "$TUDO_POST_SHELL_HOME" "$TERMUX_PREFIX" "$TERMUX_HOME" "$custom_tudo_post_shell_home_set"
		return_value=$?
		if [ $return_value -ne 0 ]; then
			tudo_log_errors "Failed to expand \"TUDO_POST_SHELL_HOME\""
			return $return_value
		fi

		#if TUDO_POST_SHELL_HOME is not a valid absolute path
		if [[ ! "$TUDO_POST_SHELL_HOME" =~ $valid_absolute_path_regex ]]; then
			tudo_log_errors "The TUDO_POST_SHELL_HOME \"$TUDO_POST_SHELL_HOME\" is not a valid absolute path"
			return 1
		fi

		#if TUDO_POST_SHELL_HOME is not set to an absolute path under TERMUX_FILES
		if [[ ! "$TUDO_POST_SHELL_HOME" =~ $valid_path_under_termux_files_regex ]]; then
			tudo_log_errors "The TUDO_POST_SHELL_HOME \"$TUDO_POST_SHELL_HOME\" must be an absolute path under TERMUX_FILES \"$TERMUX_FILES\""
		fi

		tudo_log 2 "TUDO_POST_SHELL_HOME=\"$TUDO_POST_SHELL_HOME\""

		#find the parent directory of the TUDO_POST_SHELL_HOME
		TUDO_POST_SHELL_HOME_BASENAME="${TUDO_POST_SHELL_HOME##*/}" #strip longest match of */ from start
		TUDO_POST_SHELL_HOME_PARENT_DIR="${TUDO_POST_SHELL_HOME:0:${#TUDO_POST_SHELL_HOME} - ${#TUDO_POST_SHELL_HOME_BASENAME}}" #substring from 0 to position of basename
		case $TUDO_POST_SHELL_HOME_PARENT_DIR in *[!/]*/) TUDO_POST_SHELL_HOME_PARENT_DIR=${TUDO_POST_SHELL_HOME_PARENT_DIR%"${TUDO_POST_SHELL_HOME_PARENT_DIR##*[!/]}"};; *[/]) TUDO_POST_SHELL_HOME_PARENT_DIR="/";; esac #remove trailing slashes if not root

		tudo_log 2 "TUDO_POST_SHELL_HOME_PARENT_DIR=\"$TUDO_POST_SHELL_HOME_PARENT_DIR\""
	fi


	#set TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY
	tudo_set_tudo_temp_directory_parent_directory || return $?

	#if TUDO_SHELL_WORKING_DIR is set
	if [ ! -z "$TUDO_SHELL_WORKING_DIR" ]; then
		#set TUDO_SHELL_WORKING_DIR
		tudo_set_tudo_shell_working_dir || return $?
	fi



	#create TMPDIR if missing
	tudo_setup_termux_tmp_dir || return $?


	return 0

}

#set variables to export with priority to termux or android bin and library paths
#tudo_set_priority_dependent_variables termux|android
tudo_set_priority_dependent_variables() {

	local return_value

	#if parameter count is not 1
	if [ $# -ne 1 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_set_priority_dependent_variables\""
		return 1
	fi

	local priority="$1"

	if [[ "$priority" != "termux" ]] && [[ "$priority" != "android" ]]; then
		tudo_log_errors "priority \"$priority\" passed to \"tudo_set_priority_dependent_variables\" does not equal \"termux\" or \"android\""
		return 1
	fi

	#if priority to the previous call to this function was the same, then just return
	if [[ "$priority" == "$previous_priority_dependent_variables_priortiy" ]]; then
		return 0
	fi

	tudo_log_literal 2 "\nRunning tudo_set_priority_dependent_variables with priority \"$priority\""

	#set PATH_TO_EXPORT
	#if priority equals "termux" then PATH_TO_EXPORT should be set to TERMUX_PRIORITY_PATH
	if [[ "$priority" == "termux" ]]; then
		PATH_TO_EXPORT="$TERMUX_PRIORITY_PATH"
	#if priority equals "android" then PATH_TO_EXPORT should be set to ANDROID_PRIORITY_PATH
	else
		PATH_TO_EXPORT="$ANDROID_PRIORITY_PATH"
	fi

	tudo_log 2 "PATH_TO_EXPORT=\"$PATH_TO_EXPORT\""


	#if priority equals "termux" then LD_LIBRARY_PATH_TO_EXPORT should be set to TERMUX_PRIORITY_LD_LIBRARY_PATH
	if [[ "$priority" == "termux" ]]; then
		LD_LIBRARY_PATH_TO_EXPORT="$TERMUX_PRIORITY_LD_LIBRARY_PATH"
	#if priority equals "android" then LD_LIBRARY_PATH_TO_EXPORT should be set to ANDROID_PRIORITY_LD_LIBRARY_PATH
	else
		LD_LIBRARY_PATH_TO_EXPORT="$ANDROID_PRIORITY_LD_LIBRARY_PATH"
	fi

	tudo_log 2 "LD_LIBRARY_PATH_TO_EXPORT=\"$LD_LIBRARY_PATH_TO_EXPORT\""


	#if priority equals "termux" then LD_PRELOAD_COMMAND should be set to TERMUX_PRIORITY_LD_PRELOAD_COMMAND
	if [[ "$priority" == "termux" ]]; then
		LD_PRELOAD_COMMAND="$TERMUX_PRIORITY_LD_PRELOAD_COMMAND"
	#if priority equals "android" then LD_PRELOAD_COMMAND should be set to ANDROID_PRIORITY_LD_PRELOAD_COMMAND
	else
		LD_PRELOAD_COMMAND="$ANDROID_PRIORITY_LD_PRELOAD_COMMAND"
	fi

	tudo_log 2 "LD_PRELOAD_COMMAND=\"$LD_PRELOAD_COMMAND\""


	previous_priority_dependent_variables_priortiy="$priority"

	return 0

}

tudo_set_pre_tudo_shell_commands_to_run() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_pre_tudo_shell_commands_to_run"

	local priority

	#if command_type equals "asu"
	if [[ "$command_type" == "asu" ]]; then
		#set PRE_TUDO_SHELL_COMMANDS_TO_RUN with priority to android bin and library paths
		tudo_log 2 "Setting PRE_TUDO_SHELL_COMMANDS_TO_RUN with priority to android bin and library paths since command_type is \"asu\""
		priority="android"
	#if command_type equals "path" and (TUDO_PATH_COMMAND is in /system partition or force_set_priority_to_android_paths is enabled)
	elif [[ "$command_type" == "path" ]] && ([[ "$TUDO_PATH_COMMAND" =~ $valid_path_in_system_partition_regex ]] || [[ "$force_set_priority_to_android_paths" == "1" ]]); then
		#set PRE_TUDO_SHELL_COMMANDS_TO_RUN with priority to android bin and library paths
		tudo_log 2 "Setting PRE_TUDO_SHELL_COMMANDS_TO_RUN with priority to android bin and library paths since command_type is \"path\" and TUDO_PATH_COMMAND is in \"/system\" partition or force_set_priority_to_android_paths is enabled"
		priority="android"
	else
		#set PRE_TUDO_SHELL_COMMANDS_TO_RUN with priority to termux bin and library paths
		tudo_log 2 "Setting PRE_TUDO_SHELL_COMMANDS_TO_RUN with priority to termux bin and library paths"
		priority="termux"
	fi

	#set priority_dependent_variables with new priority if needed
	tudo_set_priority_dependent_variables "$priority" || return $?

	#set PRE_TUDO_SHELL_COMMANDS_TO_RUN
	#set variables that need to be exported when running the tudo shell
	PRE_TUDO_SHELL_COMMANDS_TO_RUN=""
	PRE_TUDO_SHELL_COMMANDS_TO_RUN+="export TERMUX_PRIORITY_PATH='${TERMUX_PRIORITY_PATH//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_SHELL_COMMANDS_TO_RUN+="export TERMUX_PRIORITY_LD_LIBRARY_PATH='${TERMUX_PRIORITY_LD_LIBRARY_PATH//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_SHELL_COMMANDS_TO_RUN+="export ANDROID_PRIORITY_PATH='${ANDROID_PRIORITY_PATH//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_SHELL_COMMANDS_TO_RUN+="export ANDROID_PRIORITY_LD_LIBRARY_PATH='${ANDROID_PRIORITY_LD_LIBRARY_PATH//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_SHELL_COMMANDS_TO_RUN+="export PATH='${PATH_TO_EXPORT//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_SHELL_COMMANDS_TO_RUN+="export LD_LIBRARY_PATH='${LD_LIBRARY_PATH_TO_EXPORT//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_SHELL_COMMANDS_TO_RUN+="export PREFIX='$TERMUX_PREFIX';"$'\n'
	PRE_TUDO_SHELL_COMMANDS_TO_RUN+="export TMPDIR='$TMPDIR';"$'\n'
	PRE_TUDO_SHELL_COMMANDS_TO_RUN+="export HOME='${TUDO_SHELL_HOME//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_SHELL_COMMANDS_TO_RUN+="export TERM='${TERM//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_SHELL_COMMANDS_TO_RUN+="export LANG='${LANG//\'/\'\\\'\'}';"$'\n'

	#if command_type equals "script" and disable_stdin_for_core_script is enabled
	if [[ "$command_type" == "script" ]] && [[ "$disable_stdin_for_core_script" == "1" ]]; then
		#unset PS1 so that scripts run by script shells can check that interactive shell is not available
		PRE_TUDO_SHELL_COMMANDS_TO_RUN+="unset PS1;"$'\n'
	else
		PRE_TUDO_SHELL_COMMANDS_TO_RUN+="export PS1='${TUDO_SHELL_PS1//\'/\'\\\'\'}';"$'\n'
	fi

	#if LD_PRELOAD_COMMAND is not empty, then append it to PRE_TUDO_SHELL_COMMANDS_TO_RUN
	if [ ! -z "$LD_PRELOAD_COMMAND" ]; then
		PRE_TUDO_SHELL_COMMANDS_TO_RUN+="$LD_PRELOAD_COMMAND"$'\n'
	fi

	#if TUDO_SHELL_RCFILE_COMMANDS is not empty, then append it to PRE_TUDO_SHELL_COMMANDS_TO_RUN
	if [ ! -z "$TUDO_SHELL_RCFILE_COMMANDS" ]; then
		PRE_TUDO_SHELL_COMMANDS_TO_RUN+="$TUDO_SHELL_RCFILE_COMMANDS"$'\n'
	fi

	#if TUDO_SHELL_HISTFILE_COMMANDS is not empty, then append it to PRE_TUDO_SHELL_COMMANDS_TO_RUN
	if [ ! -z "$TUDO_SHELL_HISTFILE_COMMANDS" ]; then
		PRE_TUDO_SHELL_COMMANDS_TO_RUN+="$TUDO_SHELL_HISTFILE_COMMANDS"$'\n'
	fi

	#if set_tudo_shell_terminal_title is enabled and stdout is available, then add command to set terminal title to PRE_TUDO_SHELL_COMMANDS_TO_RUN
	if [[ "$set_tudo_shell_terminal_title" == "1" ]] && [ -t 1 ]; then
		PRE_TUDO_SHELL_COMMANDS_TO_RUN+='echo -ne "\e]0;'"$TUDO_SHELL_TERMINAL_TITLE"'\a";'$'\n'
	fi

	#if TUDO_SHELL_WORKING_DIR is set, then append cd command to PRE_TUDO_SHELL_COMMANDS_TO_RUN
	if [ ! -z "$TUDO_SHELL_WORKING_DIR" ]; then
		PRE_TUDO_SHELL_COMMANDS_TO_RUN+="cd '${TUDO_SHELL_WORKING_DIR//\'/\'\\\'\'}';"$'\n'
	fi

	#if command_type equals "su", "asu" or "path"
	if [[ "$command_type" == "su" ]] || [[ "$command_type" == "asu" ]] || [[ "$command_type" == "path" ]]; then
		#if ADDITIONAL_TUDO_SHELL_PRE_COMMANDS_TO_RUN is not empty, then append it to PRE_TUDO_SHELL_COMMANDS_TO_RUN
		if [ ! -z "$ADDITIONAL_TUDO_SHELL_PRE_COMMANDS_TO_RUN" ]; then
			PRE_TUDO_SHELL_COMMANDS_TO_RUN+="$ADDITIONAL_TUDO_SHELL_PRE_COMMANDS_TO_RUN"$'\n\n'
		fi
	fi

	#tudo_log 2 $'\n'"PRE_TUDO_SHELL_COMMANDS_TO_RUN=\"$PRE_TUDO_SHELL_COMMANDS_TO_RUN\""

	return 0

}

tudo_set_pre_tudo_post_shell_commands_to_run() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_pre_tudo_post_shell_commands_to_run"

	#set PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN with priority to termux paths
	tudo_log_literal 2 "\nSetting PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN with priority to termux paths"
	local priority="termux"

	#set priority_dependent_variables with new priority if needed
	tudo_set_priority_dependent_variables "$priority" || return $?

	#set PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN
	#set variables that need to be exported when running the tudo post shell
	PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN=""
	PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="export TERMUX_PRIORITY_PATH='${TERMUX_PRIORITY_PATH//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="export TERMUX_PRIORITY_LD_LIBRARY_PATH='${TERMUX_PRIORITY_LD_LIBRARY_PATH//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="export ANDROID_PRIORITY_PATH='${ANDROID_PRIORITY_PATH//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="export ANDROID_PRIORITY_LD_LIBRARY_PATH='${ANDROID_PRIORITY_LD_LIBRARY_PATH//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="export PATH='${PATH_TO_EXPORT//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="export LD_LIBRARY_PATH='${LD_LIBRARY_PATH_TO_EXPORT//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="export PREFIX='$TERMUX_PREFIX';"$'\n'
	PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="export TMPDIR='$TMPDIR';"$'\n'
	PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="export HOME='${TUDO_POST_SHELL_HOME//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="export TERM='${TERM//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="export LANG='${LANG//\'/\'\\\'\'}';"$'\n'
	PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="export PS1='${TUDO_POST_SHELL_PS1//\'/\'\\\'\'}';"$'\n'

	#if LD_PRELOAD_COMMAND is not empty, then append it to PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN
	if [ ! -z "$LD_PRELOAD_COMMAND" ]; then
		PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="$LD_PRELOAD_COMMAND"$'\n'
	fi

	#if TUDO_POST_SHELL_RCFILE_COMMANDS is not empty, then append it to PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN
	if [ ! -z "$TUDO_POST_SHELL_RCFILE_COMMANDS" ]; then
		PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="$TUDO_POST_SHELL_RCFILE_COMMANDS"$'\n'
	fi

	#if TUDO_POST_SHELL_HISTFILE_COMMANDS is not empty, then append it to PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN
	if [ ! -z "$TUDO_POST_SHELL_HISTFILE_COMMANDS" ]; then
		PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN+="$TUDO_POST_SHELL_HISTFILE_COMMANDS"$'\n'
	fi

	#tudo_log 2 $'\n'"PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN=\"$PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN\""

	return 0

}

tudo_set_tudo_command_path() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_tudo_command_path"

	TUDO_PATH_COMMAND="${TUDO_COMMAND[0]}"

	tudo_log 1 "TUDO_PATH_COMMAND=\"$TUDO_PATH_COMMAND\""

	#if TUDO_PATH_COMMAND is empty
	if [ -z "$TUDO_PATH_COMMAND" ]; then
		tudo_log_errors "The tudo command path \"$TUDO_PATH_COMMAND\" is empty"
		return 1
	fi

	#if force_set_priority_to_android_paths is enabled
	if [[ "$force_set_priority_to_android_paths" == "1" ]]; then
		#set priority_dependent_variables to android for PATH_TO_EXPORT used by the tudo_find_absolute_path_for_executable_and_validate function
		#we do this now and later in the tudo_set_pre_tudo_shell_commands_to_run function as well once the final TUDO_PATH_COMMAND has been set
		tudo_set_priority_dependent_variables "android" || return $?
	fi

	#find the absolute path for TUDO_PATH_COMMAND that should be used and validate it
	#TUDO_PATH_COMMAND is either considered an absolute path, otherwise searched for in current working directory or in all the paths in $PATH_TO_EXPORT variable
	tudo_find_absolute_path_for_executable_and_validate "TUDO_COMMAND_ABSOLUTE_PATH" "TUDO_PATH_COMMAND" "$TUDO_PATH_COMMAND" "$PATH_TO_EXPORT" "$TERMUX_PREFIX" "$TERMUX_HOME"
	return_value=$?
	if [ $return_value -ne 0 ] && [ $return_value -ne 112 ]; then
		tudo_log_errors "Failure while running \"tudo_find_absolute_path_for_executable_and_validate\""
		return $return_value
	elif [ $return_value -eq 112 ]; then
		tudo_log_errors "Command \"$TUDO_PATH_COMMAND\" not found"
		tudo_log_errors "Check your spelling and try again"
		return 1
	fi

	TUDO_PATH_COMMAND="$TUDO_COMMAND_ABSOLUTE_PATH"

	tudo_log 1 "TUDO_PATH_COMMAND_UPDATED=\"$TUDO_PATH_COMMAND\""

	#if TUDO_PATH_COMMAND is not a valid absolute path
	if [[ ! "$TUDO_PATH_COMMAND" =~ $valid_absolute_path_regex ]]; then
		tudo_log_errors "The TUDO_PATH_COMMAND \"$TUDO_PATH_COMMAND\" is not a valid absolute path"
		return 1
	fi

	return 0

}

tudo_set_tudo_path_command() {

	local return_value

	tudo_log_literal 2 "\n\n\nRunning tudo_set_tudo_path_command"

	#if TUDO_COMMAND is not set
	if [ ${#TUDO_COMMAND[@]} -eq 0 ]; then
		tudo_log_errors "TUDO_COMMAND is not set while running \"tudo_set_tudo_path_command\""
		return 1
	fi

	tudo_log 2 "TUDO_COMMAND_ARRAY_COUNT=\"${#TUDO_COMMAND[@]}\""

	tudo_log 2 $'\n'"TUDO_PATH_COMMAND=\`$TUDO_PATH_COMMAND\`"

	TUDO_PATH_COMMAND_TO_RUN=""

	#if "su" binary is being run, then unset LD_PRELOAD and LD_LIBRARY_PATH
	#if only "su" was passed without the '-a' option and current directory
	#did not have the "su" binary, then the wrapper script by termux at
	#$PREFIX/bin/su would ideally have been chosen by
	#the tudo_set_tudo_command_path function as TUDO_PATH_COMMAND, in
	#which case the wrapper script would ideally also automatically
	#unset the variables
	if [[ "$TUDO_PATH_COMMAND" == *"/su" ]]; then
		TUDO_PATH_COMMAND_TO_RUN="unset LD_PRELOAD; unset LD_LIBRARY_PATH; "
	fi

	#if TUDO_COMMAND argument size is 1, then only a path was passed to be executed
	if [ ${#TUDO_COMMAND[@]} -eq 1 ]; then

		TUDO_PATH_COMMAND_TO_RUN+="'${TUDO_PATH_COMMAND//\'/\'\\\'\'}'"
	#else path was passed as $1, followed by arguments that should be passed to the path
	else
		TUDO_COMMAND=("${TUDO_COMMAND[@]:1}") #remove first element since its the unparsed TUDO_PATH_COMMAND

		#if parse_commands_as_per_run_command_intent_rules is enabled
		if [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
			tudo_log 2 "Processing TUDO_PATH_COMMAND_ARGS array as per RUN_COMMAND intent rules"
		fi

		for i in "${!TUDO_COMMAND[@]}"; do
			#if parse_commands_as_per_run_command_intent_rules is enabled
			if [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
				#replace any COMMA_ALTERNATIVE characters with normal commas `,` that exist in {TUDO_COMMAND[$i]}
				if [[ "${TUDO_COMMAND[$i]}" == *"$COMMA_ALTERNATIVE"* ]]; then
					tudo_log 2 "COMMA_ALTERNATIVE found in TUDO_PATH_COMMAND_ARG $((i+1))"
					tudo_replace_comma_alternative_chars_with_commas_in_string "TUDO_COMMAND[$i]" "${TUDO_COMMAND[$i]}"
				fi
			fi

			#if disable_arguments_logging is not enabled
			if [[ "$disable_arguments_logging" != "1" ]]; then
				tudo_log 2 "TUDO_PATH_COMMAND_ARG $((i+1))=\`${TUDO_COMMAND[$i]}\`"$'\n'
			fi
		done

		printf -v "TUDO_PATH_COMMAND_ARGS" "%q " "${TUDO_COMMAND[@]}"
		TUDO_PATH_COMMAND_ARGS="${TUDO_PATH_COMMAND_ARGS% }" #remove trailing space

		TUDO_PATH_COMMAND_ARGS_LENGTH="${#TUDO_PATH_COMMAND_ARGS}"
		tudo_log 2 "TUDO_PATH_COMMAND_ARGS_LENGTH=\"$TUDO_PATH_COMMAND_ARGS_LENGTH\""


		#The `path` would not contribute much to crossing ARG_MAX since its only a path to a file, unless the path is too long
		#The ARG_MAX would be a concern only when arguments to `path` are passed via process substitution to the tudo script
		#and not as a direct argument since in that case ARG_MAX would have crossed at the point instead
		#if TUDO_PATH_COMMAND_ARGS_LENGTH is greater than TUDO_ARG_MAX_SAFE_LIMIT
		if [[ "$TUDO_PATH_COMMAND_ARGS_LENGTH" -gt "$TUDO_ARG_MAX_SAFE_LIMIT" ]]; then
			tudo_log 1 "Warning! The TUDO_PATH_COMMAND_ARGS_LENGTH \"$TUDO_PATH_COMMAND_ARGS_LENGTH\" is greater than $((TUDO_ARG_MAX_SAFE_LIMIT / 1024))KB. This may cause an \"Argument list too long\" exception."
		fi

		#pass TUDO_PATH_COMMAND_ARGS to TUDO_PATH_COMMAND
		TUDO_PATH_COMMAND_TO_RUN+=" '${TUDO_PATH_COMMAND//\'/\'\\\'\'}' $TUDO_PATH_COMMAND_ARGS"
	fi

	#if disable_arguments_logging is not enabled
	if [[ "$disable_arguments_logging" != "1" ]]; then
		tudo_log 2 $'\n'"TUDO_PATH_COMMAND_TO_RUN=\`$TUDO_PATH_COMMAND_TO_RUN\`"
	fi

	return 0

}

tudo_set_tudo_script_command() {

	local return_value

	tudo_log_literal 2 "\n\n\nRunning tudo_set_tudo_script_command"

	TUDO_SCRIPT_COMMAND_TO_RUN=$'\n'

	#append PRE_TUDO_SHELL_COMMANDS_TO_RUN to TUDO_SCRIPT_COMMAND_TO_RUN
	TUDO_SCRIPT_COMMAND_TO_RUN+="$PRE_TUDO_SHELL_COMMANDS_TO_RUN"$'\n\n'

	#if ADDITIONAL_TUDO_SHELL_PRE_COMMANDS_TO_RUN is not empty, then append it to TUDO_SCRIPT_COMMAND_TO_RUN
	if [ ! -z "$ADDITIONAL_TUDO_SHELL_PRE_COMMANDS_TO_RUN" ]; then
		TUDO_SCRIPT_COMMAND_TO_RUN+="$ADDITIONAL_TUDO_SHELL_PRE_COMMANDS_TO_RUN"$'\n\n'
	fi

	tudo_log 2 "TUDO_COMMAND_ARRAY_COUNT=\"${#TUDO_COMMAND[@]}\""

	#if a TUDO_CORE_SCRIPT or arguments passed and TUDO_CORE_SCRIPT is not empty
	#the TUDO_CORE_SCRIPT can optionally not be passed or passed as an empty string so that other "features"
	#of the "script" command_type can still be used
	if [ ${#TUDO_COMMAND[@]} -ne 0 ] && [ ! -z "${TUDO_COMMAND[0]}" ]; then

		tudo_log 2 ""

		#if parse_commands_as_per_run_command_intent_rules is enabled
		if [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
			tudo_log 2 "Processing TUDO_CORE_SCRIPT and TUDO_CORE_SCRIPT_COMMAND_ARGS array as per RUN_COMMAND intent rules"
		fi

		for i in "${!TUDO_COMMAND[@]}"; do
			#if its the TUDO_CORE_SCRIPT argument and decode_core_script_content or core_script_is_path_to_script_file is enabled
			if [ "$i" -eq 0 ] && ([[ "$decode_core_script_content" == "1" ]] ||  [[ "$core_script_is_path_to_script_file" == "1" ]]); then
				#The TUDO_COMMAND[1] contains encoded data or a path to a file so no need to process it
				continue
			fi

			#if parse_commands_as_per_run_command_intent_rules is enabled
			if [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
				#replace any COMMA_ALTERNATIVE characters with normal commas `,` that exist in {TUDO_COMMAND[$i]}
				if [[ "${TUDO_COMMAND[$i]}" == *"$COMMA_ALTERNATIVE"* ]]; then
					#if its the TUDO_CORE_SCRIPT argument
					if [ "$i" -eq 0 ]; then
						tudo_log 2 "COMMA_ALTERNATIVE found in TUDO_CORE_SCRIPT"
					else
						tudo_log 2 "COMMA_ALTERNATIVE found in TUDO_CORE_SCRIPT_COMMAND_ARG $((i+1))"
					fi
					tudo_replace_comma_alternative_chars_with_commas_in_string "TUDO_COMMAND[$i]" "${TUDO_COMMAND[$i]}"
				fi
			fi

			#if disable_arguments_logging is not enabled
			if [[ "$disable_arguments_logging" != "1" ]]; then
				#if its the TUDO_CORE_SCRIPT argument
				if [ "$i" -eq 0 ]; then
					tudo_log 2 "TUDO_CORE_SCRIPT=\`${TUDO_COMMAND[$i]}\`"$'\n'
				#else TUDO_CORE_SCRIPT was passed as $1, followed by arguments that should be passed to the script
				else
					tudo_log 2 "TUDO_CORE_SCRIPT_COMMAND_ARG $((i+1))=\`${TUDO_COMMAND[$i]}\`"$'\n'
				fi
			fi
		done

		#set the first argument as TUDO_CORE_SCRIPT
		TUDO_CORE_SCRIPT="${TUDO_COMMAND[0]}"

		#if TUDO_CORE_SCRIPT_TEMP_FILENAME is empty, then use default
		if [ -z "$TUDO_CORE_SCRIPT_TEMP_FILENAME" ]; then
			TUDO_CORE_SCRIPT_TEMP_FILENAME="tudo_core_script"
		else
			#else if user passed the filename with --script-name' option, then
			#strip longest match of */ from start, to remove any directory path passed and keep only the basename
			TUDO_CORE_SCRIPT_TEMP_FILENAME="${TUDO_CORE_SCRIPT_TEMP_FILENAME##*/}"
			#if empty, then use default
			TUDO_CORE_SCRIPT_TEMP_FILENAME="${TUDO_CORE_SCRIPT_TEMP_FILENAME:=tudo_core_script}"
		fi

		#start a new TUDO_SHELL script shell and pass TUDO_CORE_SCRIPT to it
		#the SCRIPT_ARGUMENT_FOR_SCRIPT_SHELL will contain the TUDO_CORE_SCRIPT argument that will be passed to the TUDO_SHELL
		#the way the TUDO_CORE_SCRIPT argument will be passed will depend on script shell capabilities and the options set
		#tudo_set_script_argument_for_script_shell shell_basename heredoc_word heredoc_word_quote script_is_path_to_script_file force_use_temp_script_file decode_script_content script_file_label script_file_name script_file_path/script_content
		tudo_set_script_argument_for_script_shell "$TUDO_SHELL_BASENAME" "TUDO_CORE_SCRIPT_EOF" "'" "$core_script_is_path_to_script_file" "$force_use_temp_script_file_for_core_script" "$decode_core_script_content" "TUDO_CORE_SCRIPT" "$TUDO_CORE_SCRIPT_TEMP_FILENAME" "$TUDO_CORE_SCRIPT"
		return_value=$?
		if [ $return_value -ne 0 ]; then
			tudo_log_errors "Failed to create TUDO_CORE_SCRIPT argument commands to pass them to TUDO_SHELL \"$TUDO_SHELL\""
			return $return_value
		fi

		#pass the SCRIPT_ARGUMENT_FOR_SCRIPT_SHELL set by tudo_set_script_argument_for_script_shell to TUDO_SHELL
		printf -v "TUDO_SHELL_COMMAND_STRING" "$TUDO_SHELL_COMMAND_PRINT_FORMAT" "${TUDO_SHELL_COMMAND[@]}"
		TUDO_CORE_SCRIPT_COMMAND_TO_RUN="$TUDO_SHELL_COMMAND_STRING$SCRIPT_ARGUMENT_FOR_SCRIPT_SHELL"

		#if arguments need to be passed to TUDO_CORE_SCRIPT
		if [ ${#TUDO_COMMAND[@]} -gt 1 ]; then
			TUDO_COMMAND=("${TUDO_COMMAND[@]:1}") #remove first element since its the script

			printf -v "TUDO_CORE_SCRIPT_COMMAND_ARGS" "%q " "${TUDO_COMMAND[@]}"
			TUDO_CORE_SCRIPT_COMMAND_ARGS="${TUDO_CORE_SCRIPT_COMMAND_ARGS% }" #remove trailing space

			TUDO_CORE_SCRIPT_COMMAND_ARGS_LENGTH="${#TUDO_CORE_SCRIPT_COMMAND_ARGS}"
			tudo_log 2 "TUDO_CORE_SCRIPT_COMMAND_ARGS_LENGTH=\"$TUDO_CORE_SCRIPT_COMMAND_ARGS_LENGTH\""

			#The `core_script` would not contribute much to crossing ARG_MAX since its either passed with process substitution or
			#as a path to a file storing it, unless the path is too long
			#The ARG_MAX would be a concern only when arguments to `core_script` are passed via process substitution to the tudo script
			#and not as a direct argument since in that case ARG_MAX would have crossed at the point instead
			#if TUDO_CORE_SCRIPT_COMMAND_ARGS_LENGTH is greater than TUDO_ARG_MAX_SAFE_LIMIT
			if [[ "$TUDO_CORE_SCRIPT_COMMAND_ARGS_LENGTH" -gt "$TUDO_ARG_MAX_SAFE_LIMIT" ]]; then
				tudo_log 1 "Warning! The TUDO_CORE_SCRIPT_COMMAND_ARGS_LENGTH \"$TUDO_CORE_SCRIPT_COMMAND_ARGS_LENGTH\" is greater than $((TUDO_ARG_MAX_SAFE_LIMIT / 1024))KB. This may cause an \"Argument list too long\" exception."
			fi

			#pass the arguments to the TUDO_SHELL after the SCRIPT_ARGUMENT_FOR_SCRIPT_SHELL
			TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=" $TUDO_CORE_SCRIPT_COMMAND_ARGS"
		fi

		#if TUDO_CORE_SCRIPT_REDIRECT_MODE or TUDO_SHELL_STDIN_STRING is set or
		#disable_stdin_for_core_script or run_core_script_in_background is enabled
		if [ ! -z "$TUDO_CORE_SCRIPT_REDIRECT_MODE" ] || \
			[ ! -z "$TUDO_SHELL_STDIN_STRING" ] || \
				[[ "$disable_stdin_for_core_script" == "1" ]] || \
					[[ "$run_core_script_in_background" == "1" ]]; then
			#surround TUDO_CORE_SCRIPT_COMMAND_TO_RUN with command grouping
			TUDO_CORE_SCRIPT_COMMAND_TO_RUN="{"$'\n\n'"$TUDO_CORE_SCRIPT_COMMAND_TO_RUN"$'\n\n''}'

			#if TUDO_CORE_SCRIPT_REDIRECT_MODE is set
			if [ ! -z "$TUDO_CORE_SCRIPT_REDIRECT_MODE" ]; then

				#if TUDO_CORE_SCRIPT_REDIRECT_MODE equal "0", then redirect stderr to stdout
				if [[ "$TUDO_CORE_SCRIPT_REDIRECT_MODE" == "0" ]]; then
					TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=' 2>&1'

				#elif TUDO_CORE_SCRIPT_REDIRECT_MODE equal "1", then redirect stdout to stderr
				elif [[ "$TUDO_CORE_SCRIPT_REDIRECT_MODE" == "1" ]]; then
					TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=' 1>&2'

				#elif TUDO_CORE_SCRIPT_REDIRECT_MODE equal "2", then redirect stdout to /dev/null
				elif [[ "$TUDO_CORE_SCRIPT_REDIRECT_MODE" == "2" ]]; then
					TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=' 1>/dev/null'

				#elif TUDO_CORE_SCRIPT_REDIRECT_MODE equal "3", then redirect stderr to /dev/null
				elif [[ "$TUDO_CORE_SCRIPT_REDIRECT_MODE" == "3" ]]; then
					TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=' 2>/dev/null'

				#elif TUDO_CORE_SCRIPT_REDIRECT_MODE equal "4", then redirect both stdout and stderr to /dev/null
				elif [[ "$TUDO_CORE_SCRIPT_REDIRECT_MODE" == "4" ]]; then
					TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=' &>/dev/null'

				#elif TUDO_CORE_SCRIPT_REDIRECT_MODE equal "5", then redirect stderr to stdout and redirect stdout to stderr
				elif [[ "$TUDO_CORE_SCRIPT_REDIRECT_MODE" == "5" ]]; then
					TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=' 3>&2 2>&1 1>&3'

				#elif TUDO_CORE_SCRIPT_REDIRECT_MODE equal "6", then redirect stderr to stdout and redirect stdout to /dev/null
				elif [[ "$TUDO_CORE_SCRIPT_REDIRECT_MODE" == "6" ]]; then
					TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=' 2>&1 1>/dev/null'

				#else append TUDO_CORE_SCRIPT_REDIRECT_MODE to TUDO_CORE_SCRIPT_COMMAND_TO_RUN
				else
					TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=" $TUDO_CORE_SCRIPT_REDIRECT_MODE"

				fi
			fi

			#if TUDO_SHELL_STDIN_STRING is set
			if [ ! -z "$TUDO_SHELL_STDIN_STRING" ]; then
				#if TUDO_SHELL_BASENAME is in TUDO_SCRIPT_SHELLS_WITHOUT_PROCESS_SUBSTITUTION_SUPPORT
				if [[ " $TUDO_SCRIPT_SHELLS_WITHOUT_PROCESS_SUBSTITUTION_SUPPORT " == *" $TUDO_SHELL_BASENAME "* ]]; then
					#pass TUDO_SHELL_STDIN_STRING as stdin with a herestring to TUDO_SHELL
					TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=' <<<'"'${TUDO_SHELL_STDIN_STRING//\'/\'\\\'\'}'"
				else
					#pass TUDO_SHELL_STDIN_STRING as stdin with process substitution to TUDO_SHELL
					TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=' < <(printf "%s" '"'${TUDO_SHELL_STDIN_STRING//\'/\'\\\'\'}'"')'
				fi
			else
				#if disable_stdin_for_core_script is enabled, then redirect stdin to /dev/null
				if [[ "$disable_stdin_for_core_script" == "1" ]]; then
					TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=' < /dev/null'
				fi
			fi

			#if run_core_script_in_background is enabled, then start TUDO_CORE_SCRIPT in background
			if [[ "$run_core_script_in_background" == "1" ]]; then
				TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=' &'
				TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=$'\n''export TUDO_SCRIPT_PID=$!;'
				TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=$'\n''export TUDO_SCRIPT_EXIT_CODE=0;'
			fi

			TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=$'\n\n'
		fi

		#if run_core_script_in_background is not enabled
		if [[ "$run_core_script_in_background" != "1" ]]; then
			TUDO_CORE_SCRIPT_COMMAND_TO_RUN+=$'\n''export TUDO_SCRIPT_EXIT_CODE=$?;'$'\n\n'

			#if exit_early_if_core_script_fails is enabled, then exit if TUDO_SCRIPT_EXIT_CODE does not equal 0
			if [[ "$exit_early_if_core_script_fails" == "1" ]]; then
				TUDO_CORE_SCRIPT_COMMAND_TO_RUN+='[ $TUDO_SCRIPT_EXIT_CODE -ne 0 ] && exit $TUDO_SCRIPT_EXIT_CODE'$'\n\n'
			fi
		fi

		#append TUDO_CORE_SCRIPT_COMMAND_TO_RUN to TUDO_SCRIPT_COMMAND_TO_RUN
		TUDO_SCRIPT_COMMAND_TO_RUN+="$TUDO_CORE_SCRIPT_COMMAND_TO_RUN"

	else
		#append dummy TUDO_SCRIPT_EXIT_CODE to TUDO_SCRIPT_COMMAND_TO_RUN
		TUDO_SCRIPT_COMMAND_TO_RUN+='export TUDO_SCRIPT_EXIT_CODE=0;'$'\n\n'
	fi

	#if ADDITIONAL_TUDO_SHELL_POST_COMMANDS_TO_RUN is not empty, then append it to TUDO_SCRIPT_COMMAND_TO_RUN
	if [ ! -z "$ADDITIONAL_TUDO_SHELL_POST_COMMANDS_TO_RUN" ]; then
		TUDO_SCRIPT_COMMAND_TO_RUN+="$ADDITIONAL_TUDO_SHELL_POST_COMMANDS_TO_RUN"$'\n\n'
	fi

	#if go_back_to_last_activity_after_running_core_script is enabled, then simulate double back button press to go to the last activity, first to close keyboard and second to close terminal session
	if [[ "$go_back_to_last_activity_after_running_core_script" == "1" ]]; then
		TUDO_SCRIPT_COMMAND_TO_RUN+='$(export PATH="$ANDROID_PRIORITY_PATH"; export LD_LIBRARY_PATH="$ANDROID_PRIORITY_LD_LIBRARY_PATH"; unset LD_PRELOAD; input keyevent KEYCODE_BACK; input keyevent KEYCODE_BACK;);'$'\n\n'
	#if go_to_launcher_activity_after_running_core_script is enabled, then simulate home button press to go to the launcher activity
	elif [[ "$go_to_launcher_activity_after_running_core_script" == "1" ]]; then
		TUDO_SCRIPT_COMMAND_TO_RUN+='$(export PATH="$ANDROID_PRIORITY_PATH"; export LD_LIBRARY_PATH="$ANDROID_PRIORITY_LD_LIBRARY_PATH"; unset LD_PRELOAD; am start --user 0 -a android.intent.action.MAIN -c android.intent.category.HOME &>/dev/null;);'$'\n\n'
	fi

	#if clear_shell_after_running_core_script is enabled, then add clear command
	if [[ "$clear_shell_after_running_core_script" == "1" ]]; then
		TUDO_SCRIPT_COMMAND_TO_RUN+="clear"$'\n'
	fi

	#if run_interactive_post_tudo_shell_after_running_core_script is enabled, start a new interactive post shell
	#we do not check if stdout and stdin are available since tudo could be piped or redirected and may not be connected to a tty
	#the -t 0 and -t 1 checks fail if tudo is run in a simple subshell in android 10 but not on 7
	if [[ "$run_interactive_post_tudo_shell_after_running_core_script" == "1" ]]; then
		#append PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN
		TUDO_SCRIPT_COMMAND_TO_RUN+="$PRE_TUDO_POST_SHELL_COMMANDS_TO_RUN"$'\n'

		#if ADDITIONAL_TUDO_POST_SHELL_PRE_COMMANDS_TO_RUN is not empty, then append it to TUDO_SCRIPT_COMMAND_TO_RUN
		if [ ! -z "$ADDITIONAL_TUDO_POST_SHELL_PRE_COMMANDS_TO_RUN" ]; then
			TUDO_SCRIPT_COMMAND_TO_RUN+="$ADDITIONAL_TUDO_POST_SHELL_PRE_COMMANDS_TO_RUN"$'\n'
		fi

		printf -v "TUDO_POST_SHELL_INTERACTIVE_COMMAND_STRING" "$TUDO_POST_SHELL_INTERACTIVE_COMMAND_PRINT_FORMAT" "${TUDO_POST_SHELL_INTERACTIVE_COMMAND[@]}"
		TUDO_POST_SHELL_INTERACTIVE_COMMAND_STRING="${TUDO_POST_SHELL_INTERACTIVE_COMMAND_STRING% }" #remove trailing space

		#if TUDO_POST_SHELL_STDIN_STRING is set
		if [ ! -z "$TUDO_POST_SHELL_STDIN_STRING" ]; then
			#surround TUDO_POST_SHELL_INTERACTIVE_COMMAND_STRING with command grouping
			TUDO_POST_SHELL_INTERACTIVE_COMMAND_STRING="{"$'\n\n'"$TUDO_POST_SHELL_INTERACTIVE_COMMAND_STRING"$'\n\n''}'

			#if TUDO_POST_SHELL_BASENAME is in TUDO_SCRIPT_SHELLS_WITHOUT_PROCESS_SUBSTITUTION_SUPPORT
			if [[ " $TUDO_SCRIPT_SHELLS_WITHOUT_PROCESS_SUBSTITUTION_SUPPORT " == *" $TUDO_POST_SHELL_BASENAME "* ]]; then
				#pass TUDO_POST_SHELL_STDIN_STRING as stdin with a herestring to TUDO_POST_SHELL
				TUDO_POST_SHELL_INTERACTIVE_COMMAND_STRING+=' <<<'"'${TUDO_POST_SHELL_STDIN_STRING//\'/\'\\\'\'}'"
			else
				#pass TUDO_POST_SHELL_STDIN_STRING as stdin with process substitution to TUDO_POST_SHELL
				TUDO_POST_SHELL_INTERACTIVE_COMMAND_STRING+=' < <(printf "%s" '"'${TUDO_POST_SHELL_STDIN_STRING//\'/\'\\\'\'}'"')'
			fi
		fi

		TUDO_SCRIPT_COMMAND_TO_RUN+="$TUDO_POST_SHELL_INTERACTIVE_COMMAND_STRING"$'\n'

		#if ADDITIONAL_TUDO_POST_SHELL_POST_COMMANDS_TO_RUN is not empty, then append it to TUDO_SCRIPT_COMMAND_TO_RUN
		if [ ! -z "$ADDITIONAL_TUDO_POST_SHELL_POST_COMMANDS_TO_RUN" ]; then
			TUDO_SCRIPT_COMMAND_TO_RUN+="$ADDITIONAL_TUDO_POST_SHELL_POST_COMMANDS_TO_RUN"$'\n'
		fi
	else
		#exit with exit code of TUDO_CORE_SCRIPT
		TUDO_SCRIPT_COMMAND_TO_RUN+='exit $TUDO_SCRIPT_EXIT_CODE'$'\n'
	fi



	#set TUDO_SCRIPT_COMMAND_TRAPS and TUDO_SCRIPT_COMMAND_TRAPS_REMOVE_TEMP_DIRECTORY_FUNCTION
	tudo_create_script_command_traps
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failed to create traps commands for TUDO_TEMP_DIRECTORY \"$TUDO_TEMP_DIRECTORY\""
		return $return_value
	fi

	#if TUDO_SCRIPT_COMMAND_TRAPS is set
	if [ ! -z "$TUDO_SCRIPT_COMMAND_TRAPS" ]; then
		#if a script shell that doesn't support process substitution is being used or '-f' is passed, then
		#tudo_set_script_argument_for_script_shell_for_tudo will store temp core_script file at TUDO_CORE_SCRIPT_TEMP_FILENAME in TUDO_TEMP_DIRECTORY
		#add traps at start of TUDO_SCRIPT_COMMAND_TO_RUN to remove the TUDO_TEMP_DIRECTORY when the script exits
		TUDO_SCRIPT_COMMAND_TO_RUN=$'\n'"$TUDO_SCRIPT_COMMAND_TRAPS"$'\n'"$TUDO_SCRIPT_COMMAND_TO_RUN"
	fi

	#if disable_arguments_logging is not enabled
	#if [[ "$disable_arguments_logging" != "1" ]]; then
	#	tudo_log 2 $'\n'"TUDO_SCRIPT_COMMAND_TO_RUN=\`$TUDO_SCRIPT_COMMAND_TO_RUN\`"
	#fi

	return 0

}

#tudo_set_script_argument_for_script_shell shell_basename heredoc_word heredoc_word_quote script_is_path_to_script_file force_use_temp_script_file decode_script_content script_file_label script_file_name script_file_path/script_content
tudo_set_script_argument_for_script_shell() {

	local return_value

	#if parameter count is not 9
	if [ $# -ne 9 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_set_script_argument_for_script_shell\""
		return 1
	fi

	local shell_basename="$1"
	local heredoc_word="$2"
	local heredoc_word_quote="$3"
	local script_is_path_to_script_file="$4"
	local force_use_temp_script_file="$5"
	local decode_script_content="$6"
	local script_file_label="$7"
	local script_file_name="$8"

	#if shell_basename is not in any of the TUDO_SUPPORTED_SCRIPT_SHELLS, then exit with error
	if [[ "$shell_basename" == *' '* ]] || [[ " $TUDO_SUPPORTED_SCRIPT_SHELLS " != *" $shell_basename "* ]]; then
		tudo_log_errors "The shell_basename \"$shell_basename\" while running \"tudo_set_script_argument_for_script_shell\" is not supported. It must be one of \"$TUDO_SUPPORTED_SCRIPT_SHELLS\""
		return 1
	fi

	SCRIPT_ARGUMENT_FOR_SCRIPT_SHELL=""

	#if script_is_path_to_script_file is enabled, then just pass script_file_path as the argument to the script shell
	if [[ "$script_is_path_to_script_file" == "1" ]]; then
		local script_file_path="$9"

		tudo_log 2 "$script_file_label will be passed to the script shell as a path to a file"

		#replace "$PREFIX/" or "~/" prefix with termux absolute paths in script_file_path
		tudo_expand_termux_path "script_file_path" "$script_file_label" "$script_file_path" "$TERMUX_PREFIX" "$TERMUX_HOME" 1
		return_value=$?
		if [ $return_value -ne 0 ]; then
			tudo_log_errors "Failed to expand $script_file_label \"$script_file_path\""
			return $return_value
		fi

		#if script_file_path is not a valid absolute path
		if [[ ! "$script_file_path" =~ $valid_absolute_path_regex ]]; then
			tudo_log_errors "The $script_file_label \"$script_file_path\" is not a valid absolute path"
			return 1
		fi

		tudo_log 2 "script_file_path=\"$script_file_path\""
		printf -v "script_file_path_string" "%q" "$script_file_path"
		SCRIPT_ARGUMENT_FOR_SCRIPT_SHELL="$script_file_path_string"

	else
		local script_content="$9"

		#if shell is in TUDO_SCRIPT_SHELLS_WITHOUT_PROCESS_SUBSTITUTION_SUPPORT (dash, sh, node, php)
		#or force_use_temp_script_file is enabled
		#store the script in a temp script file in TUDO_TEMP_DIRECTORY and pass that as argument to the script shell
		if [[ " $TUDO_SCRIPT_SHELLS_WITHOUT_PROCESS_SUBSTITUTION_SUPPORT " == *" $shell_basename "* ]] || [[ "$force_use_temp_script_file" == "1" ]]; then
			local log_content=1

			#if disable_arguments_logging is enabled
			if [[ "$disable_arguments_logging" == "1" ]]; then
				log_content=0
			fi

			tudo_log 2 "$script_file_label will be passed to the script shell after being store in a temp file"

			#setup TUDO_TEMP_DIRECTORY
			tudo_setup_tudo_temp_directory
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "Failure while running \"tudo_setup_tudo_temp_directory\""
				return $return_value
			fi

			#if TUDO_TEMP_DIRECTORY is not a valid absolute path
			if [[ ! "$TUDO_TEMP_DIRECTORY" =~ $valid_absolute_path_regex ]]; then
				tudo_log_errors "The TUDO_TEMP_DIRECTORY \"$TUDO_TEMP_DIRECTORY\" is not a valid absolute path, required by \"tudo_set_script_argument_for_script_shell\""
				return 1
			fi

			script_file="$TUDO_TEMP_DIRECTORY/$script_file_name"

			tudo_log 2 "$script_file_label temp file=\"$script_file\""

			#tudo_create_tudo_temp_file label path log_content decode_content content
			tudo_create_tudo_temp_file "$script_file_label" "$script_file" "$log_content" "$decode_script_content" "$script_content"
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "Failure while running \"tudo_create_tudo_temp_file\""
				return $return_value
			fi

			printf -v "script_file_string" "%q" "$script_file"
			SCRIPT_ARGUMENT_FOR_SCRIPT_SHELL="$script_file_string"

		#if shell is bash, zsh, fish, ksh, python python2, ruby, perl, lua5.2, lua5.3, lua5.4
		#use process substitution with printf to pass script_content to the script shell
		#heredoc is not used since that will create a temp file in TMPDIR which is slower and less secure
		#note that ARG_MAX will not cross because of passing the script_content as an argument to printf
		#since printf is a shell built-in and exec is not done. It will however cross if an external call were to
		#be made to printf with `$PREFIX/bin/print`. The ARG_MAX would be a concern only when `core_script`
		#is passed via process substitution to the tudo script and not as a direct argument since in that
		#case ARG_MAX would have crossed at the point instead
		elif [[ " bash zsh fish ksh python python2 ruby perl lua5.2 lua5.3 lua5.4 " == *" $shell_basename "* ]]; then

			tudo_log 2 "$script_file_label will be passed to the script shell using process substitution with printf command"

			SCRIPT_ARGUMENT_FOR_SCRIPT_SHELL='<(printf "%s" '"'${script_content//\'/\'\\\'\'}
'"')'

			#tudo_log 2 "$script_file_label will be passed to the script shell using process substitution with a cat heredoc"

#			SCRIPT_ARGUMENT_FOR_SCRIPT_SHELL='<(cat <<'"$heredoc_word_quote$heredoc_word$heredoc_word_quote"'
#'"$script_content"'
#
#'"$heredoc_word"'
#)'


		else
			tudo_log_errors "shell_basename \"$shell_basename\" not handled while running \"tudo_set_script_argument_for_script_shell\""
			return 1
		fi
	fi

	return 0

}

#tudo_create_tudo_temp_file label path log_content decode_content content
tudo_create_tudo_temp_file() {

	local return_value

	#if parameter count is not 5
	if [ $# -ne 5 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_create_tudo_temp_file\""
		return 1
	fi

	local label="$1"
	local path="$2"
	local log_content="$3"
	local decode_content="$4"
	local content="$5"

	#if path is not a valid absolute path
	if [[ ! "$path" =~ $valid_absolute_path_regex ]]; then
		tudo_log_errors "The \"$label\" file at path \"$path\" is not an absolute path"
		return 2
	fi

	#write the contents to file at path
	#decode first if required
	#decoding of binary data needs to be done on the fly since
	#binary data cannot be stored in a variable

	tudo_log 2 "Creating $label file at \"$path\""

	if [[ "$decode_content" == "1" ]]; then
		printf '%s' "$content" | base64 -d > "$path"
	else
		printf '%s' "$content" > "$path"
	fi
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failure while creating $label file at \"$path\""
		return $return_value
	fi

	#read file at path again and log its content but only if binary data is not stored in it
	if [[ $tudo_verbose_level -ge 1 ]] && [[ "$log_content" == "1" ]]  && [[ "$decode_content" != "1" ]]; then
		local file_contents=""
		file_contents="$(cat "$path")"
		tudo_log 1 $'\n'"${label}_CONTENTS=\`$file_contents\`"
	fi

	return 0

}

tudo_set_tudo_shell() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_tudo_shell"

	#if TUDO_SHELL is set
	if [ ! -z "$TUDO_SHELL" ]; then
		tudo_trim_trailing_newlines "TUDO_SHELL" "$TUDO_SHELL"

		#validate the TUDO_SHELL
		tudo_validate_shell "TUDO_SHELL" "TUDO_SHELL" "$TUDO_SHELL" "$TUDO_SUPPORTED_SHELLS" "$TERMUX_PREFIX" "$TERMUX_BIN" "$TERMUX_HOME"
		return_value=$?
		if [ $return_value -ne 0 ]; then
			tudo_log_errors "Failed to validate \"TUDO_SHELL\""
			return $return_value
		fi
	else
		#default to bash as TUDO_SHELL
		TUDO_SHELL="$BASH_SHELL_PATH"
	fi

	#if TUDO_SHELL is not a valid absolute path
	if [[ ! "$TUDO_SHELL" =~ $valid_absolute_path_regex ]]; then
		tudo_log_errors "The TUDO_SHELL \"$TUDO_SHELL\" is not a valid absolute path"
		return 1
	fi

	tudo_log 1 "TUDO_SHELL=\"$TUDO_SHELL\""

	#find the basename and parent directory of the TUDO_SHELL
	TUDO_SHELL_BASENAME="${TUDO_SHELL##*/}" #strip longest match of */ from start
	TUDO_SHELL_PARENT_DIR="${TUDO_SHELL:0:${#TUDO_SHELL} - ${#TUDO_SHELL_BASENAME}}" #substring from 0 to position of basename
	case $TUDO_SHELL_PARENT_DIR in *[!/]*/) TUDO_SHELL_PARENT_DIR=${TUDO_SHELL_PARENT_DIR%"${TUDO_SHELL_PARENT_DIR##*[!/]}"};; *[/]) TUDO_SHELL_PARENT_DIR="/";; esac #remove trailing slashes if not root

	tudo_log 2 "TUDO_SHELL_BASENAME=\"$TUDO_SHELL_BASENAME\""
	tudo_log 2 "TUDO_SHELL_PARENT_DIR=\"$TUDO_SHELL_PARENT_DIR\""

	#if TUDO_SHELL is not in any of the TUDO_SUPPORTED_SHELLS, then exit with error
	#the basename of the shell file could be faked but the actual shell inside the file is not checked
	if [[ "$TUDO_SHELL_BASENAME" == *' '* ]] || [[ " $TUDO_SUPPORTED_SHELLS " != *" $TUDO_SHELL_BASENAME "* ]]; then
		tudo_log_errors "The TUDO_SHELL \"$TUDO_SHELL\" is not supported. It must be one of \"$TUDO_SUPPORTED_SHELLS\""
		return 1
	fi

	return 0

}

tudo_set_tudo_post_shell() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_tudo_post_shell"

	#if TUDO_POST_SHELL is set
	if [ ! -z "$TUDO_POST_SHELL" ]; then
		tudo_trim_trailing_newlines "TUDO_POST_SHELL" "$TUDO_POST_SHELL"

		#validate the TUDO_POST_SHELL
		tudo_validate_shell "TUDO_POST_SHELL" "TUDO_POST_SHELL" "$TUDO_POST_SHELL" "$TUDO_SUPPORTED_POST_SHELLS" "$TERMUX_PREFIX" "$TERMUX_BIN" "$TERMUX_HOME"
		return_value=$?
		if [ $return_value -ne 0 ]; then
			tudo_log_errors "Failed to validate \"TUDO_POST_SHELL\""
			return $return_value
		fi
	else
		#default to bash as TUDO_POST_SHELL
		TUDO_POST_SHELL="$BASH_SHELL_PATH"
	fi

	#if TUDO_POST_SHELL is not a valid absolute path
	if [[ ! "$TUDO_POST_SHELL" =~ $valid_absolute_path_regex ]]; then
		tudo_log_errors "The TUDO_POST_SHELL \"$TUDO_POST_SHELL\" is not a valid absolute path"
		return 1
	fi

	tudo_log 1 "TUDO_POST_SHELL=\"$TUDO_POST_SHELL\""

	#find the basename and parent directory of the TUDO_POST_SHELL
	TUDO_POST_SHELL_BASENAME="${TUDO_POST_SHELL##*/}" #strip longest match of */ from start
	TUDO_POST_SHELL_PARENT_DIR="${TUDO_POST_SHELL:0:${#TUDO_POST_SHELL} - ${#TUDO_POST_SHELL_BASENAME}}" #substring from 0 to position of basename
	case $TUDO_POST_SHELL_PARENT_DIR in *[!/]*/) TUDO_POST_SHELL_PARENT_DIR=${TUDO_POST_SHELL_PARENT_DIR%"${TUDO_POST_SHELL_PARENT_DIR##*[!/]}"};; *[/]) TUDO_POST_SHELL_PARENT_DIR="/";; esac #remove trailing slashes if not root

	tudo_log 2 "TUDO_POST_SHELL_BASENAME=\"$TUDO_POST_SHELL_BASENAME\""
	tudo_log 2 "TUDO_POST_SHELL_PARENT_DIR=\"$TUDO_POST_SHELL_PARENT_DIR\""

	#if TUDO_POST_SHELL is not in any of the TUDO_SUPPORTED_SHELLS, then exit with error
	#the basename of the shell file could be faked but the actual shell inside the file is not checked
	if [[ "$TUDO_POST_SHELL_BASENAME" == *' '* ]] || [[ " $TUDO_SUPPORTED_POST_SHELLS " != *" $TUDO_POST_SHELL_BASENAME "* ]]; then
		tudo_log_errors "The TUDO_POST_SHELL \"$TUDO_POST_SHELL\" is not supported. It must be one of \"$TUDO_SUPPORTED_POST_SHELLS\""
		return 1
	fi

	return 0

}

#tudo_validate_shell variable_name shell_label user_shell supported_shells termux_prefix termux_bin termux_home
tudo_validate_shell() {

	local return_value

	#if parameter count is not 7
	if [ $# -ne 7 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_validate_shell\""
		return 1
	fi

	local variable_name="$1"
	local shell_label="$2"
	local user_shell="$3"
	local supported_shells="$4"
	local termux_prefix="$5"
	local termux_bin="$6"
	local termux_home="$7"

	local shell

	#if user_shell is set to a shell in supported_shells, then set user_shell to "$termux_bin/$user_shell"
	if [[ "$user_shell" != *'/'* ]]; then
		if [[ "$user_shell" != *' '* ]] && [[ " $supported_shells " == *" $user_shell "* ]]; then
			shell="$termux_bin/$user_shell"
		else
			tudo_log_errors "The $shell_label \"$user_shell\" is not supported. It must be one of \"$supported_shells\""
			return 1
		fi
	else
		#replace "$PREFIX/" or "~/" prefix with termux absolute paths in user_shell
		tudo_expand_termux_path "user_shell" "$shell_label" "$user_shell" "$termux_prefix" "$termux_home" 1
		return_value=$?
		if [ $return_value -ne 0 ]; then
			tudo_log_errors "Failed to expand $shell_label \"$user_shell\""
			return $return_value
		fi

		shell="$user_shell"
	fi

	#tudo_run_file_type_tests_on_path label path log_file_tests_failure_errors show_stat_output_on_file_tests_failure check_if_absolute_path file_type_tests
	tudo_run_file_type_tests_on_path "$shell_label" "$shell" 1 1 1 "frx" || return $?


	local valid_bash_variable_name_regex='^[a-zA-Z][a-zA-Z0-9_]*(\[[0-9]+\])?$'

	#if variable_name does not equal "shell" and is valid bash variable_name
	if [[ "$variable_name" != "shell" ]] && [[ "$variable_name" =~ $valid_bash_variable_name_regex ]]; then
		#set variable_name to shell
		printf -v "$variable_name" "%s" "$shell"
	else
		tudo_log_errors "variable_name \"$1\" passed to \"tudo_expand_termux_path\" equals \"shell\" or is not a valid bash variable name"
		return 1
	fi

}

tudo_set_tudo_shell_rcfile() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_tudo_shell_rcfile"

	#set rcfile variables
	tudo_set_shell_rcfile "TUDO_SHELL" "$TUDO_SHELL_BASENAME" "$TUDO_SHELL_HOME" "$tudo_shell_share_rcfiles_and_histfiles"
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failure while running \"tudo_set_rcfile_functions\" for TUDO_SHELL \"$TUDO_SHELL\""
		return $return_value
	fi

	TUDO_SHELL_RCFILE="$SHELL_RCFILE"
	TUDO_SHELL_RCFILE_PARENT_DIR="$SHELL_RCFILE_PARENT_DIR"
	TUDO_SHELL_RCFILE_COMMANDS="$SHELL_RCFILE_COMMANDS"
	TUDO_SHELL_RCFILE_VALUE="$SHELL_RCFILE_VALUE"
	TUDO_SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS+=("${SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}")


	tudo_log 2 "TUDO_SHELL_RCFILE=\"$TUDO_SHELL_RCFILE\""
	tudo_log 2 "TUDO_SHELL_RCFILE_PARENT_DIR=\"$TUDO_SHELL_RCFILE_PARENT_DIR\""
	tudo_log 2 "TUDO_SHELL_RCFILE_COMMANDS=\"$TUDO_SHELL_RCFILE_COMMANDS\""
	tudo_log 2 "TUDO_SHELL_RCFILE_VALUE=\`$TUDO_SHELL_RCFILE_VALUE\`"

	return 0

}

tudo_set_tudo_post_shell_rcfile() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_tudo_post_shell_rcfile"

	#set rcfile variables
	tudo_set_shell_rcfile "TUDO_POST_SHELL" "$TUDO_POST_SHELL_BASENAME" "$TUDO_POST_SHELL_HOME" "$tudo_post_shell_share_rcfiles_and_histfiles"
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failure while running \"tudo_set_rcfile_functions\" for TUDO_POST_SHELL \"$TUDO_POST_SHELL\""
		return $return_value
	fi

	TUDO_POST_SHELL_RCFILE="$SHELL_RCFILE"
	TUDO_POST_SHELL_RCFILE_PARENT_DIR="$SHELL_RCFILE_PARENT_DIR"
	TUDO_POST_SHELL_RCFILE_COMMANDS="$SHELL_RCFILE_COMMANDS"
	TUDO_POST_SHELL_RCFILE_VALUE="$SHELL_RCFILE_VALUE"
	TUDO_POST_SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS+=("${SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}")


	tudo_log 2 "TUDO_POST_SHELL_RCFILE=\"$TUDO_POST_SHELL_RCFILE\""
	tudo_log 2 "TUDO_POST_SHELL_RCFILE_PARENT_DIR=\"$TUDO_POST_SHELL_RCFILE_PARENT_DIR\""
	tudo_log 2 "TUDO_POST_SHELL_RCFILE_COMMANDS=\"$TUDO_POST_SHELL_RCFILE_COMMANDS\""
	tudo_log 2 "TUDO_POST_SHELL_RCFILE_VALUE=\`$TUDO_POST_SHELL_RCFILE_VALUE\`"

	return 0

}

#tudo_set_shell_rcfile shell_basename shell_home shell_share_rcfiles
tudo_set_shell_rcfile() {

	local return_value

	#if parameter count is not 4
	if [ $# -ne 4 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_set_shell_rcfile\""
		return 1
	fi

	local shell_label="$1"
	local shell_basename="$2"
	local shell_home="$3"
	local shell_share_rcfiles="$4"

	#RCFILE are usually unique for different shells
	#if shell_home==TERMUX_HOME, then termux shells and tudo shells
	#will share rc files by default unless shell_share_rcfiles is
	#enabled and the shell supports --rc param or an environmental
	#variable

	#was going to add support for tcsh but decided not to after reading the following and having a chuckle
	#https://web.fe.up.pt/~jmcruz/etc/unix/sh-vs-csh.html

	SHELL_RCFILE=""
	SHELL_RCFILE_PARENT_DIR=""
	SHELL_RCFILE_COMMANDS=""
	SHELL_RCFILE_VALUE=""
	SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS=()

	#if shell is zsh
	if [[ "$shell_basename" == "zsh" ]]; then
		#if shell_home==TERMUX_HOME, then termux shell and tudo shell rc files are shared
		#since only the parent dir of ".zshrc" file can be defined in ZDOTDIR
		SHELL_RCFILE="$shell_home/.zshrc"
		SHELL_RCFILE_COMMANDS="export ZDOTDIR='${shell_home//\'/\'\\\'\'}';"

	#if shell is fish
	elif [[ "$shell_basename" == "fish" ]]; then
		#if shell_home==TERMUX_HOME, then termux shell and tudo shell rc files are shared since "config.fish" is always loaded
		SHELL_RCFILE="$shell_home/.config/fish/config.fish"
		SHELL_RCFILE_COMMANDS="export XDG_CONFIG_HOME='${shell_home//\'/\'\\\'\'}/.config';"
		SHELL_RCFILE_COMMANDS+=$'\n'"export XDG_CACHE_HOME='${shell_home//\'/\'\\\'\'}/.cache';"
		SHELL_RCFILE_COMMANDS+=$'\n'"export XDG_DATA_HOME='${shell_home//\'/\'\\\'\'}/.local/share';"
		SHELL_RCFILE_COMMANDS+=$'\n'"export XDG_RUNTIME_DIR='$TMPDIR';"
		SHELL_RCFILE_COMMANDS+=$'\n'"[ ! -d \"\$XDG_CONFIG_HOME\" ] && mkdir -p \"\$XDG_CONFIG_HOME\";"
		SHELL_RCFILE_COMMANDS+=$'\n'"[ ! -d \"\$XDG_CACHE_HOME\" ] && mkdir -p \"\$XDG_CACHE_HOME\";"
		SHELL_RCFILE_COMMANDS+=$'\n'"[ ! -d \"\$XDG_DATA_HOME\" ] && mkdir -p \"\$XDG_DATA_HOME\";"

	#if shell is ruby
	elif [[ "$shell_basename" == "ruby" ]]; then
		#if shell_home==TERMUX_HOME, then termux shell and tudo shell rc files are shared since "~/.irbrc" is always loaded
		SHELL_RCFILE="$shell_home/.irbrc"

	#if shell is pry
	elif [[ "$shell_basename" == "pry" ]]; then
		#if shell_home==TERMUX_HOME, then termux shell and tudo shell rc files are shared since "~/.pryrc" is always loaded
		SHELL_RCFILE="$shell_home/.pryrc"

	#if shell is bash, dash, sh, ksh, php, python
	elif [[ " bash dash sh ksh python php python2 " == *" $shell_basename "* ]]; then
		#if shell_home==TERMUX_HOME and shell_share_rcfiles is not enabled, then set the RCFILE with "tudo_" appended to it
		#so that termux shell and tudo shell rc files are not shared since --rc params or
		#environmental variables can be used to define the path to the rc file
		local shell_rcfile_subname
		if [[ "$shell_home" == "$TERMUX_HOME" ]] && [[ "$shell_share_rcfiles" != "1" ]]; then
			shell_rcfile_subname="tudo_${shell_basename}"
		else
			shell_rcfile_subname="${shell_basename}"
		fi

		#if shell is bash
		if [[ "$shell_basename" == "bash" ]]; then
			#use the --rcfile param to pass the path to rcfile
			SHELL_RCFILE="$shell_home/.${shell_rcfile_subname}rc"
			SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS+=("--rcfile" "$SHELL_RCFILE")

		#if shell is python, python2
		elif [[ " python python2 " == *" $shell_basename "* ]]; then
			#use the PYTHONSTARTUP environmental variable to pass the path to rcfile
			SHELL_RCFILE="$shell_home/.${shell_rcfile_subname}rc"
			SHELL_RCFILE_COMMANDS="export PYTHONSTARTUP='${SHELL_RCFILE//\'/\'\\\'\'}';"

		#if shell is php
		elif [[ "$shell_basename" == "php" ]]; then
			#use the -c param to pass the path to ini file
			SHELL_RCFILE="$shell_home/${shell_rcfile_subname}.ini"
			SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS+=("-c" "$SHELL_RCFILE")

		#if shell is dash, sh, ksh
		else
			#use the PYTHONSTARTUP environmental variable to pass the path to rcfile
			SHELL_RCFILE="$shell_home/.${shell_rcfile_subname}rc"
			SHELL_RCFILE_COMMANDS="export ENV='${SHELL_RCFILE//\'/\'\\\'\'}';"
		fi

	#if shell is node, perl, lua5.2, lua5.3, lua5.4
	elif [[ " node perl lua5.2 lua5.3 lua5.4 " == *" $shell_basename "* ]]; then
		#the shell does not have a rc file or does not use it
		tudo_log 2 "The \"$shell_basename\" shell does not have a rc file or does not use it"
	else
		tudo_log_errors "shell_basename \"$shell_basename\" not handled while running \"tudo_set_shell_rcfile\""
		return 1
	fi


	#if SHELL_RCFILE is set
	if [ ! -z "$SHELL_RCFILE" ]; then

		#if SHELL_RCFILE is not a valid absolute path
		if [[ ! "$SHELL_RCFILE" =~ $valid_absolute_path_regex ]]; then
			tudo_log_errors "The ${shell_label}_RCFILE \"$SHELL_RCFILE\" is not a valid absolute path"
			return 1
		fi

		#if SHELL_RCFILE_COMMANDS is set
		if [ ! -z "$SHELL_RCFILE_COMMANDS" ]; then
			SHELL_RCFILE_COMMANDS+=$'\n'
		fi

		SHELL_RCFILE_COMMANDS+="export RCFILE='${SHELL_RCFILE//\'/\'\\\'\'}';"


		#find the parent directory of the SHELL_RCFILE
		SHELL_RCFILE_BASENAME="${SHELL_RCFILE##*/}" #strip longest match of */ from start
		SHELL_RCFILE_PARENT_DIR="${SHELL_RCFILE:0:${#SHELL_RCFILE} - ${#SHELL_RCFILE_BASENAME}}" #substring from 0 to position of basename
		case $SHELL_RCFILE_PARENT_DIR in *[!/]*/) SHELL_RCFILE_PARENT_DIR=${SHELL_RCFILE_PARENT_DIR%"${SHELL_RCFILE_PARENT_DIR##*[!/]}"};; *[/]) SHELL_RCFILE_PARENT_DIR="/";; esac #remove trailing slashes if not root

		#set SHELL_RCFILE_VALUE to be set in SHELL_RCFILE
		SHELL_RCFILE_VALUE=""

		#if shell is bash, zsh, dash, sh, fish or ksh
		if [[ " bash zsh dash sh fish ksh " == *" $shell_basename "* ]]; then
			#not defining any variables since they are dynamically defined by "tudo" command
			#overriding may create problems in the future as well if dynamically defined variable values change
			#PATH, LD_LIBRARY_PATH and PS1 must never be overridden in rcfile, otherwise "tudo" commands will not work properly,
			#specially the "tudo asu" and "tudo <command>" commands

			#define any required functions to add to SHELL_RCFILE_VALUE in RCFILE_FUNCTIONS
			tudo_set_rcfile_functions "$shell_basename" || return $?

			#if RCFILE_FUNCTIONS is not empty, then append it to SHELL_RCFILE_VALUE
			if [ ! -z "$RCFILE_FUNCTIONS" ]; then
				SHELL_RCFILE_VALUE+="$RCFILE_FUNCTIONS"$'\n'
			fi
		fi
	fi

	return 0

}

#tudo_set_rcfile_functions
tudo_set_rcfile_functions() {

	local return_value

	#if parameter count is not 1
	if [ $# -ne 1 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_set_rcfile_functions\""
		return 1
	fi

	local shell_basename="$1"

	RCFILE_FUNCTIONS=""

	#if shell is fish
	if [[ "$shell_basename" == "fish" ]]; then

		#define export helper function for fish shell that allows export command in bash to be used
		FISH_SHELL_EXPORT_FUNCTION='
function export
    if [ $argv ]
        set var (echo $argv | cut -f1 -d=)
        set val (echo $argv | cut -f2 -d=)
        set -g -x $var $val
    end
end

funcsave -q export
'

		#define unset helper function for fish shell that allows export command in bash to be used
		FISH_SHELL_UNSET_FUNCTION='
function unset
    set --erase $argv
end

funcsave -q unset
'

	#define tpath helper function for fish shell that sets priority to termux paths
	FISH_SHELL_TPATH_FUNCTION='
function tpath
    export PATH="$TERMUX_PRIORITY_PATH";
    export LD_LIBRARY_PATH="$TERMUX_PRIORITY_LD_LIBRARY_PATH";
    '"$TERMUX_PRIORITY_LD_PRELOAD_COMMAND"'
end
'

	#define apath helper function for fish shell that sets priority to android paths
	FISH_SHELL_APATH_FUNCTION='
function apath
    export PATH="$ANDROID_PRIORITY_PATH";
    export LD_LIBRARY_PATH="$ANDROID_PRIORITY_LD_LIBRARY_PATH";
    '"$ANDROID_PRIORITY_LD_PRELOAD_COMMAND"'
end
'

		RCFILE_FUNCTIONS="$FISH_SHELL_EXPORT_FUNCTION"
		RCFILE_FUNCTIONS+=$'\n'"$FISH_SHELL_UNSET_FUNCTION"
		RCFILE_FUNCTIONS+=$'\n'"$FISH_SHELL_TPATH_FUNCTION"
		RCFILE_FUNCTIONS+=$'\n'"$FISH_SHELL_APATH_FUNCTION"





	#if shell is bash, zsh, dash, sh or ksh
	elif [[ " bash zsh dash sh ksh " == *" $shell_basename "* ]]; then

		#define tpath helper function for bash, zsh, sh, etc shells that sets priority to termux paths
		GENERAL_SHELL_TPATH_FUNCTION='
tpath() {
    export PATH="$TERMUX_PRIORITY_PATH";
    export LD_LIBRARY_PATH="$TERMUX_PRIORITY_LD_LIBRARY_PATH";
    '"$TERMUX_PRIORITY_LD_PRELOAD_COMMAND"'
}
'


		#define apath helper function for bash, zsh, sh, etc shells that sets priority to android paths
		GENERAL_SHELL_APATH_FUNCTION='
apath() {
    export PATH="$ANDROID_PRIORITY_PATH";
    export LD_LIBRARY_PATH="$ANDROID_PRIORITY_LD_LIBRARY_PATH";
    '"$ANDROID_PRIORITY_LD_PRELOAD_COMMAND"'
}
'


		RCFILE_FUNCTIONS="$GENERAL_SHELL_TPATH_FUNCTION"
		RCFILE_FUNCTIONS+=$'\n'"$GENERAL_SHELL_APATH_FUNCTION"

	fi

	return 0

}

tudo_set_tudo_shell_histfile() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_tudo_shell_histfile"

	#set histfile variables
	tudo_set_shell_histfile "TUDO_SHELL" "$TUDO_SHELL_BASENAME" "$TUDO_SHELL_HOME" "$tudo_shells_history_enabled" "$tudo_shell_share_rcfiles_and_histfiles"
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failure while running \"tudo_set_shell_histfile\" for TUDO_SHELL \"$TUDO_SHELL\""
		return $return_value
	fi

	TUDO_SHELL_HISTFILE="$SHELL_HISTFILE"
	TUDO_SHELL_HISTFILE_PARENT_DIR="$SHELL_HISTFILE_PARENT_DIR"
	TUDO_SHELL_HISTFILE_COMMANDS="$SHELL_HISTFILE_COMMANDS"
	TUDO_SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS+=("${SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}")

	tudo_log 2 "TUDO_SHELL_HISTFILE=\"$TUDO_SHELL_HISTFILE\""
	tudo_log 2 "TUDO_SHELL_HISTFILE_PARENT_DIR=\"$TUDO_SHELL_HISTFILE_PARENT_DIR\""
	tudo_log 2 "TUDO_SHELL_HISTFILE_COMMANDS=\"$TUDO_SHELL_HISTFILE_COMMANDS\""

	return 0

}

tudo_set_tudo_post_shell_histfile() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_tudo_post_shell_histfile"

	#set histfile variables
	tudo_set_shell_histfile "TUDO_POST_SHELL" "$TUDO_POST_SHELL_BASENAME" "$TUDO_POST_SHELL_HOME" "$tudo_shells_history_enabled" "$tudo_post_shell_share_rcfiles_and_histfiles"
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failure while running \"tudo_set_shell_histfile\" for TUDO_POST_SHELL \"$TUDO_POST_SHELL\""
		return $return_value
	fi

	TUDO_POST_SHELL_HISTFILE="$SHELL_HISTFILE"
	TUDO_POST_SHELL_HISTFILE_PARENT_DIR="$SHELL_HISTFILE_PARENT_DIR"
	TUDO_POST_SHELL_HISTFILE_COMMANDS="$SHELL_HISTFILE_COMMANDS"
	TUDO_POST_SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS+=("${SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}")

	tudo_log 2 "TUDO_POST_SHELL_HISTFILE=\"$TUDO_POST_SHELL_HISTFILE\""
	tudo_log 2 "TUDO_POST_SHELL_HISTFILE_PARENT_DIR=\"$TUDO_POST_SHELL_HISTFILE_PARENT_DIR\""
	tudo_log 2 "TUDO_POST_SHELL_HISTFILE_COMMANDS=\"$TUDO_POST_SHELL_HISTFILE_COMMANDS\""

	return 0

}

#tudo_set_shell_histfile shell_label shell_basename shell_home shell_history_enabled shell_share_histfiles
tudo_set_shell_histfile() {

	local return_value

	#if parameter count is not 5
	if [ $# -ne 5 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_set_shell_histfile\""
		return 1
	fi

	local shell_label="$1"
	local shell_basename="$2"
	local shell_home="$3"
	local shell_history_enabled="$4"
	local shell_share_histfiles="$5"

	SHELL_HISTFILE=""
	SHELL_HISTFILE_PARENT_DIR=""
	SHELL_HISTFILE_COMMANDS=""
	SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS=()

	#if shell_history_enabled is enabled
	if [[ "$shell_history_enabled" == "1" ]]; then

		#history files are usually unique for different shells
		#if shell_home==TERMUX_HOME, then termux shells and tudo shells
		#will share history files by default unless
		#shell_share_histfiles is enabled and the shell supports
		#HISTFILE variable

		#if shell is fish
		if [[ "$shell_basename" == "fish" ]]; then
			local histfile_session_id

			#if shell_home and TERMUX_HOME are same and shell_share_histfiles is not enabled, then
			#set the HISTFILE with "tudo_" appended to it to keep tudo shells command history separate
			#from termux shells
			if [[ "$shell_home" == "$TERMUX_HOME" ]] && [[ "$shell_share_histfiles" != "1" ]]; then
				histfile_session_id="tudo_fish"
			else
				histfile_session_id="fish"
			fi

			#fish uses the variable fish_history to store the session id for the history file
			#the history file ends up being "${fish_history}_history"
			SHELL_HISTFILE="$shell_home/.local/share/fish/${histfile_session_id}_history"
			SHELL_HISTFILE_COMMANDS="export fish_history='$histfile_session_id';"

		#if shell is python
		elif [[ "$shell_basename" == "python" ]]; then
			#python uses "~/.python_history" file to store history by default
			#history feature was introduced in 3.4
			SHELL_HISTFILE="$shell_home/.python_history"

		#if shell is ruby
		elif [[ "$shell_basename" == "ruby" ]]; then
			#irb uses "~/.irb_history" file to store history by default
			#if rvm is used, then its "~/.irb-history"
			#there are no params or environmental variables that can be used to set history settings
			#history settings can be changed by defining following config options in "~/.irbrc" file
			#IRB.conf[:HISTORY_FILE] = "~/.irb_history"
			#IRB.conf[:SAVE_HISTORY] = 1000
			SHELL_HISTFILE="$shell_home/.irb_history"

		#if shell is pry
		elif [[ "$shell_basename" == "pry" ]]; then
			#pry uses "~/.pry_history" file to store history by default
			#there are no params or environmental variables that can be used to set history settings
			#history settings can be changed by defining following config options in "~/.pryrc" file
			#Pry.config.history_file = "~/.pry_history"
			#Pry.config.history_load = true
			#Pry.config.history_save = true
			SHELL_HISTFILE="$shell_home/.pry_history"

		#if shell is php
		elif [[ "$shell_basename" == "php" ]]; then
			#php uses "~/.php_history" file to store history by default
			SHELL_HISTFILE="$shell_home/.php_history"

		#if shell is bash, zsh, dash, sh, ksh, node, perl
		elif [[ " bash zsh dash sh ksh node perl " == *" $shell_basename "* ]]; then
			#if shell_home and TERMUX_HOME are same and shell_share_histfiles is not enabled, then
			#set the HISTFILE with "tudo_" appended to it to keep tudo shells command history separate
			#from termux shells
			local shell_histfile_subname
			if [[ "$shell_home" == "$TERMUX_HOME" ]] && [[ "$shell_share_histfiles" != "1" ]]; then
				shell_histfile_subname="tudo_${shell_basename}"
			else
				shell_histfile_subname="${shell_basename}"
			fi

			#if shell is bash
			if [[ "$shell_basename" == "bash" ]]; then
				#bash uses HISTFILE environment variable for history file
				SHELL_HISTFILE="$shell_home/.${shell_histfile_subname}_history"
				SHELL_HISTFILE_COMMANDS="export HISTSIZE=1000;"
				SHELL_HISTFILE_COMMANDS+=$'\n'"export HISTFILESIZE=1000;"
			#if shell is zsh
			elif [[ "$shell_basename" == "zsh" ]]; then
				#zsh uses HISTFILE environment variable for history file
				SHELL_HISTFILE="$shell_home/.${shell_histfile_subname}_history"
				SHELL_HISTFILE_COMMANDS="export HISTSIZE=1000;"
				SHELL_HISTFILE_COMMANDS+=$'\n'"export SAVEHIST=1000;"

			#if shell is node
			elif [[ "$shell_basename" == "node" ]]; then
				#node uses NODE_REPL_HISTORY to define path for history file
				#and NODE_REPL_HISTORY_SIZE for size of history file
				SHELL_HISTFILE="$shell_home/.${shell_histfile_subname}_history"
				SHELL_HISTFILE_COMMANDS="export NODE_REPL_HISTORY='${SHELL_HISTFILE//\'/\'\\\'\'}';"
				SHELL_HISTFILE_COMMANDS+=$'\n'"export NODE_REPL_HISTORY_SIZE=1000;"

			#if shell is perl
			elif [[ "$shell_basename" == "perl" ]]; then
				#use rlwrap "--history-filename" and "--histsize" params to set history settings
				SHELL_HISTFILE="$shell_home/.${shell_histfile_subname}_history"
				TUDO_RLWRAP_ADDITIONAL_COMMAND_OPTIONS+=("--history-filename" "$SHELL_HISTFILE" "--histsize" "1000")

			#if shell is dash sh ksh
			else
				#the shells use HISTFILE environment variable for history file
				SHELL_HISTFILE="$shell_home/.${shell_histfile_subname}_history"
			fi

		#if shell is python2, lua5.2, lua5.3, lua5.4
		elif [[ " python2 lua5.2 lua5.3 lua5.4 " == *" $shell_basename "* ]]; then
			#the shell does not have a history file or does not use it
			tudo_log 2 "The \"$shell_basename\" shell does not have a history file or does not use it"

		else
			tudo_log_errors "shell_basename \"$shell_basename\" not handled while running \"tudo_set_shell_histfile\""
			return 1
		fi


		#if SHELL_HISTFILE is set
		if [ ! -z "$SHELL_HISTFILE" ]; then
			#if SHELL_HISTFILE is not a valid absolute path
			if [[ ! "$SHELL_HISTFILE" =~ $valid_absolute_path_regex ]]; then
				tudo_log_errors "The ${shell_label}_HISTFILE \"$SHELL_HISTFILE\" is not a valid absolute path"
				return 1
			fi

			#if SHELL_HISTFILE_COMMANDS is set
			if [ ! -z "$SHELL_HISTFILE_COMMANDS" ]; then
				SHELL_HISTFILE_COMMANDS+=$'\n'
			fi

			SHELL_HISTFILE_COMMANDS+="export HISTFILE='${SHELL_HISTFILE//\'/\'\\\'\'}';"

			#find the parent directory of the SHELL_HISTFILE
			SHELL_HISTFILE_BASENAME="${SHELL_HISTFILE##*/}" #strip longest match of */ from start
			SHELL_HISTFILE_PARENT_DIR="${SHELL_HISTFILE:0:${#SHELL_HISTFILE} - ${#SHELL_HISTFILE_BASENAME}}" #substring from 0 to position of basename
			case $SHELL_HISTFILE_PARENT_DIR in *[!/]*/) SHELL_HISTFILE_PARENT_DIR=${SHELL_HISTFILE_PARENT_DIR%"${SHELL_HISTFILE_PARENT_DIR##*[!/]}"};; *[/]) SHELL_HISTFILE_PARENT_DIR="/";; esac #remove trailing slashes if not root
		fi

	else
		#if shell is fish
		if [[ "$shell_basename" == "fish" ]]; then
			#fish uses '--private' flag to disable history
			SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS+=("--private")

		#if shell is python
		elif [[ "$shell_basename" == "python" ]]; then
			#disable the "readline.write_history_file" function that writes history to file
			SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS+=("-c" 'import readline; readline.write_history_file = lambda *args: None')

		#if shell is pry
		elif [[ "$shell_basename" == "pry" ]]; then
			#use the "Pry.config.history_save" config to disable history saving
			#the "--no-history" flag to disable history loading is raising an exception in pry-0.13.1
			#using the "Pry.config.history_load" config option with "-e" to disable history loading
			#does not work, since its already loaded by the time its run
			SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS+=("-e" 'Pry.config.history_save = false;')

		#if shell is node
		elif [[ "$shell_basename" == "node" ]]; then
			#node uses NODE_REPL_HISTORY to define path for history file
			#unsetting it disables history
			SHELL_HISTFILE_COMMANDS="export NODE_REPL_HISTORY='';"

		#if shell is perl
		elif [[ "$shell_basename" == "perl" ]]; then
			#use rlwrap "--history-filename" to set history settings
			TUDO_RLWRAP_ADDITIONAL_COMMAND_OPTIONS+=("--history-filename" "/dev/null")

		#if shell is bash, zsh, dash, sh, ksh
		elif [[ " bash zsh dash sh ksh " == *" $shell_basename "* ]]; then
			#if shell is bash
			#if [[ "$shell_basename" == "bash" ]]; then
				#bash uses 'history' shopt_option to control history, so unset it with a command option
				#for some reason this does not work since bash shell automatically enables history by default for interactive shells
				#can be confirmed by running "shopt -o" in a new interactive shell
				#SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS+=("+o" "history")
			#fi

			#unsetting HISTFILE does not work for all shells like bash since it sets the default value if HISTFILE is not set
			#HISTFILE may still be overridden in a startup or a rc file
			SHELL_HISTFILE_COMMANDS="export HISTFILE='/dev/null';"

		#if shell is ruby, lua5.2, lua5.3, lua5.4, php, python2
		elif [[ " ruby lua5.2 lua5.3 lua5.4 php python2 " == *" $shell_basename "* ]]; then
			#the shell does not have a history file or does not use it or cannot be disabled using any params or environmental variables
			tudo_log 2 "The \"$shell_basename\" shell does not have a history file or does not use it or cannot be disabled using any params or environmental variables"

		else
			tudo_log_errors "shell_basename \"$shell_basename\" not handled while running \"tudo_set_shell_histfile\""
			return 1
		fi
	fi

	return 0

}

tudo_set_tudo_shell_command() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_tudo_shell_command"

	SHELL_ADDITIONAL_COMMAND_OPTIONS=("${TUDO_SHELL_ADDITIONAL_COMMAND_OPTIONS[@]}")
	SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS=("${TUDO_SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}")

	#set shell command variables
	tudo_set_shell_command "TUDO_SHELL" "$TUDO_SHELL" "$TUDO_SHELL_BASENAME" "$TUDO_SHELL_PARENT_DIR" "$interactive_tudo_shell_required"
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failure while running \"tudo_set_shell_command\" for TUDO_SHELL \"$TUDO_SHELL\""
		return $return_value
	fi

	TUDO_SHELL_COMMAND=("${SHELL_COMMAND[@]}")
	TUDO_SHELL_INTERACTIVE_COMMAND=("${SHELL_INTERACTIVE_COMMAND[@]}")
	TUDO_SHELL_COMMAND_PRINT_FORMAT="$SHELL_COMMAND_PRINT_FORMAT"
	TUDO_SHELL_INTERACTIVE_COMMAND_PRINT_FORMAT="$SHELL_INTERACTIVE_COMMAND_PRINT_FORMAT"


	tudo_log 2 "TUDO_SHELL_COMMAND=\"${TUDO_SHELL_COMMAND[*]}\""
	tudo_log 2 "TUDO_SHELL_INTERACTIVE_COMMAND=\"${TUDO_SHELL_INTERACTIVE_COMMAND[*]}\""

	return 0

}

tudo_set_tudo_post_shell_command() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_tudo_post_shell_command"

	SHELL_ADDITIONAL_COMMAND_OPTIONS=()
	SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS=("${TUDO_POST_SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}")

	#set shell command variables
	tudo_set_shell_command "TUDO_POST_SHELL" "$TUDO_POST_SHELL" "$TUDO_POST_SHELL_BASENAME" "$TUDO_POST_SHELL_PARENT_DIR" 1
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failure while running \"tudo_set_shell_command\" for TUDO_POST_SHELL \"$TUDO_POST_SHELL\""
		return $return_value
	fi

	TUDO_POST_SHELL_INTERACTIVE_COMMAND=("${SHELL_INTERACTIVE_COMMAND[@]}")
	TUDO_POST_SHELL_INTERACTIVE_COMMAND_PRINT_FORMAT="$SHELL_INTERACTIVE_COMMAND_PRINT_FORMAT"

	tudo_log 2 "TUDO_POST_SHELL_INTERACTIVE_COMMAND=\"${TUDO_POST_SHELL_INTERACTIVE_COMMAND[*]}\""

	return 0

}

#tudo_set_shell_command shell_label shell shell_basename shell_parent_dir interactive_shell_required
tudo_set_shell_command() {

	local return_value

	#if parameter count is not 5
	if [ $# -ne 5 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_set_shell_command\""
		return 1
	fi

	local shell_label="$1"
	local shell="$2"
	local shell_basename="$3"
	local shell_parent_dir="$4"
	local interactive_shell_required="$5"

	local shell_dependency_label=""
	local shell_dependency=""
	local shell_interactive_dependency_label=""
	local shell_interactive_dependency=""

	SHELL_COMMAND_PRINT_FORMAT="%q "
	SHELL_INTERACTIVE_COMMAND_PRINT_FORMAT="%q "

	#if shell is bash
	if [[ "$shell_basename" == "bash" ]]; then
		SHELL_COMMAND=("$shell" "--noprofile" "--norc" "${SHELL_ADDITIONAL_COMMAND_OPTIONS[@]}")
		SHELL_INTERACTIVE_COMMAND=("$shell" "${SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}" "-i")

	#if shell is zsh
	elif [[ "$shell_basename" == "zsh" ]]; then
		SHELL_COMMAND=("$shell" "--no-rcs" "${SHELL_ADDITIONAL_COMMAND_OPTIONS[@]}")
		SHELL_INTERACTIVE_COMMAND=("$shell" "${SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}" "-i")

	#if shell is python, python2
	elif [[ " python python2 " == *" $shell_basename "* ]]; then
		SHELL_COMMAND=("$shell" "${SHELL_ADDITIONAL_COMMAND_OPTIONS[@]}")
		SHELL_INTERACTIVE_COMMAND=("$shell" "-i" "${SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}")

	#if shell is ruby
	elif [[ "$shell_basename" == "ruby" ]]; then
		#the ruby interactive shell is named irb
		SHELL_COMMAND=("$shell" "${SHELL_ADDITIONAL_COMMAND_OPTIONS[@]}")
		SHELL_INTERACTIVE_COMMAND=("$shell_parent_dir/irb" "${SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}")

		shell_interactive_dependency_label="irb"
		shell_interactive_dependency="$TERMUX_BIN/irb"

	#if shell is pry
	elif [[ "$shell_basename" == "pry" ]]; then
		#pry does not support passing scripts, ruby must be used instead
		SHELL_COMMAND=()
		SHELL_INTERACTIVE_COMMAND=("$shell" "${SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}")

	#if shell is perl
	elif [[ "$shell_basename" == "perl" ]]; then
		SHELL_COMMAND=("$shell" "${SHELL_ADDITIONAL_COMMAND_OPTIONS[@]}")

		#the perl interactive shell is started with rlwrap
		#rlwrap -A -pgreen -S "perl> " perl -wnE 'say eval()//$@'
		local shell_interactive_command_string;
		printf -v "shell_interactive_command_string" "%q " \
			"$TERMUX_BIN/rlwrap" "-A" "-pgreen" "-S" "perl> " "${TUDO_RLWRAP_ADDITIONAL_COMMAND_OPTIONS[@]}" \
				"$shell_parent_dir/perl" "${SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}" "-wnE" 'say eval()//$@'
		SHELL_INTERACTIVE_COMMAND=("$shell_interactive_command_string")
		SHELL_INTERACTIVE_COMMAND_PRINT_FORMAT="%s"

		shell_interactive_dependency_label="rlwrap"
		shell_interactive_dependency="$TERMUX_BIN/rlwrap"

	#if shell is php
	elif [[ "$shell_basename" == "php" ]]; then
		SHELL_COMMAND=("$shell" "${SHELL_ADDITIONAL_COMMAND_OPTIONS[@]}")
		SHELL_INTERACTIVE_COMMAND=("$shell" "${SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}" "-a")

	#if shell is dash, sh, ksh, fish, node, lua5.2, lua5.3, lua5.4
		elif [[ " dash sh ksh fish node lua5.2 lua5.3 lua5.4 " == *" $shell_basename "* ]]; then
		SHELL_COMMAND=("$shell" "${SHELL_ADDITIONAL_COMMAND_OPTIONS[@]}")
		SHELL_INTERACTIVE_COMMAND=("$shell" "${SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS[@]}" "-i")
	else
		tudo_log_errors "shell_basename \"$shell_basename\" not handled while running \"tudo_set_shell_command\""
		return 1
	fi

	#if interactive_shell_required is not enabled
	if [[ "$interactive_shell_required" != "1" ]]; then
		#if shell_dependency is set
		if [ ! -z "$shell_dependency" ]; then
			tudo_run_file_type_tests_on_path "$shell_dependency_label" "$shell_dependency" 1 1 1 "frx"
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "\"$shell_dependency_label\" is required to run non-interactive \"$shell_basename\" shell"
				return $return_value
			fi
		fi
	else
		#if shell_interactive_dependency is set
		if [ ! -z "$shell_interactive_dependency" ]; then
			tudo_run_file_type_tests_on_path "$shell_interactive_dependency_label" "$shell_interactive_dependency" 1 1 1 "frx"
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "\"$shell_interactive_dependency_label\" is required to run interactive \"$shell_basename\" shell"
				return $return_value
			fi
		fi
	fi

	return 0

}

tudo_setup_tudo_shell_home_and_working_environment() {

	local return_value

	tudo_log_literal 2 "\n\n\nRunning tudo_setup_tudo_shell_home_and_working_environment"

	#tudo_setup_shell_home shell_label shell_home_parent_dir shell_home shell_automatically_create_rc_file shell_rcfile_parent_dir shell_rcfile shell_rcfile_value  shell_histfile_parent_dir shell_histfile
	tudo_setup_shell_home "TUDO_SHELL" "$TUDO_SHELL_HOME_PARENT_DIR" "$TUDO_SHELL_HOME" "$tudo_shells_automatically_create_rc_files" "$TUDO_SHELL_RCFILE_PARENT_DIR" "$TUDO_SHELL_RCFILE" "$TUDO_SHELL_RCFILE_VALUE" "$tudo_shells_automatically_create_history_files" "$TUDO_SHELL_HISTFILE_PARENT_DIR" "$TUDO_SHELL_HISTFILE"
	return_value=$?
	if [ $return_value -ne 0 ] && [ $return_value -ne 112 ]; then
		tudo_log_errors "Failed to setup TUDO_SHELL_HOME"
		return $return_value
	fi

	#if TUDO_POST_SHELL_HOME is set
	if [ ! -z "$TUDO_POST_SHELL_HOME" ]; then
		#if TUDO_SHELL and TUDO_POST_SHELL home, rcfile or histfiles are different
		if [[ "$TUDO_POST_SHELL_HOME" != "$TUDO_SHELL_HOME" ]] || \
				[[ "$TUDO_POST_SHELL_RCFILE" != "$TUDO_SHELL_RCFILE" ]] || \
			 		[[ "$TUDO_POST_SHELL_HISTFILE" != "$TUDO_SHELL_HISTFILE" ]]; then
			#tudo_setup_shell_home shell_label shell_home_parent_dir shell_home shell_automatically_create_rc_file shell_rcfile_parent_dir shell_rcfile shell_rcfile_value shell_histfile_parent_dir  shell_histfile
			tudo_setup_shell_home "TUDO_POST_SHELL"  "$TUDO_POST_SHELL_HOME_PARENT_DIR" "$TUDO_POST_SHELL_HOME" "$tudo_shells_automatically_create_rc_files" "$TUDO_POST_SHELL_RCFILE_PARENT_DIR" "$TUDO_POST_SHELL_RCFILE" "$TUDO_POST_SHELL_RCFILE_VALUE" "$tudo_shells_automatically_create_history_files" "$TUDO_POST_SHELL_HISTFILE_PARENT_DIR" "$TUDO_POST_SHELL_HISTFILE"
			return_value=$?
			if [ $return_value -ne 0 ] && [ $return_value -ne 112 ]; then
				tudo_log_errors "Failed to setup TUDO_POST_SHELL_HOME"
				return $return_value
			fi
		fi
	fi

	#if TUDO_SHELL_WORKING_DIR is set
	if [ ! -z "$TUDO_SHELL_WORKING_DIR" ]; then
		#create TUDO_SHELL_WORKING_DIR if missing
		tudo_setup_tudo_shell_working_dir || return $?
	fi

	return 0

}

#tudo_setup_shell_home shell_label shell_home_parent_dir shell_home shell_automatically_create_rc_file shell_rcfile_parent_dir shell_rcfile shell_rcfile_value  shell_histfile_parent_dir shell_histfile
tudo_setup_shell_home() {

	local return_value

	#if parameter count is not 10
	if [ $# -ne 10 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_setup_shell_home\""
		return 1
	fi

	local shell_label="$1"
	local shell_home_parent_dir="$2"
	local shell_home="$3"
	local shell_automatically_create_rc_file="$4"
	local shell_rcfile_parent_dir="$5"
	local shell_rcfile="$6"
	local shell_rcfile_value="$7"
	local shell_automatically_create_history_file="$8"
	local shell_histfile_parent_dir="$9"
	local shell_histfile="${10}"

	local create_shell_home_if_it_does_not_exist
	local only_set_perms_and_ownership_on_creation_of_shell_home
	local shell_home_ownership
	local shell_home_permission
	local shell_home_file_type_tests

	local create_shell_rcfile_parent_dir_if_it_does_not_exist
	local only_set_perms_and_ownership_on_creation_of_shell_rcfile_parent_dir
	local shell_rcfile_parent_dir_ownership
	local shell_rcfile_parent_dir_permission
	local shell_rcfile_parent_dir_file_type_tests

	local create_shell_rcfile_if_it_does_not_exist
	local only_set_perms_and_ownership_on_creation_of_shell_rcfile
	local shell_rcfile_ownership
	local shell_rcfile_permission
	local shell_rcfile_file_type_tests

	local create_shell_histfile_parent_dir_if_it_does_not_exist
	local only_set_perms_and_ownership_on_creation_of_shell_histfile_parent_dir
	local shell_histfile_parent_dir_ownership
	local shell_histfile_parent_dir_permission
	local shell_histfile_parent_dir_file_type_tests

	local create_shell_histfile_if_it_does_not_exist
	local only_set_perms_and_ownership_on_creation_of_shell_histfile
	local shell_histfile_ownership
	local shell_histfile_permission
	local shell_histfile_file_type_tests

	local validation_result

	tudo_log_literal 2 "\nRunning tudo_setup_shell_home for $shell_label"



	create_shell_home_if_it_does_not_exist=1
	only_set_perms_and_ownership_on_creation_of_shell_home=1
	shell_home_permission="700"
	shell_home_file_type_tests="rwx"

	#validate if shell_home is a whitelisted path under TERMUX_FILES
	tudo_validate_path_is_a_whitelisted_path_under_termux_files "${shell_label}_HOME" "$shell_home"
	return_value=$?
	if [ $return_value -ne 0 ] && [ $return_value -ne 2 ] &&  [ $return_value -ne 3 ]; then
		return $return_value
	fi

	validation_result=$return_value

	#if shell_home is a whitelisted path under TERMUX_FILES
	if [ $validation_result -eq 0 ]; then
		shell_home_ownership="--reference=\"$TERMUX_FILES\""
	#if shell_home is a blacklisted path under TERMUX_FILES or is not under TERMUX_FILES
	else
		tudo_log_errors "The \"$shell_home\" cannot be used as ${shell_label}_HOME"
		return 1
	fi



	#if shell_automatically_create_rc_file is not enabled or dry_run_tudo is enabled, then unset shell_rcfile
	if [[ "$shell_automatically_create_rc_file" != "1" ]] || [[ "$dry_run_tudo" == "1" ]]; then
		shell_rcfile=""
	fi

	#if shell_rcfile is set
	if [ ! -z "$shell_rcfile" ]; then
		#if shell_rcfile_parent_dir is not the same as shell_home or one of subdirectories
		if [[ "$shell_rcfile_parent_dir" != "$shell_home" ]] && [[ "$shell_rcfile_parent_dir" != "$shell_home"/* ]]; then
			tudo_log_errors "The ${shell_label}_RCFILE_PARENT_DIR \"$shell_rcfile_parent_dir\" must be same as ${shell_label}_HOME \"$shell_home\" or be one of its subdirectories"
			return 1
		fi

		create_shell_rcfile_parent_dir_if_it_does_not_exist=1
		only_set_perms_and_ownership_on_creation_of_shell_rcfile_parent_dir=1
		shell_rcfile_parent_dir_permission="700"
		shell_rcfile_parent_dir_file_type_tests="rwx"

		create_shell_rcfile_if_it_does_not_exist=1
		only_set_perms_and_ownership_on_creation_of_shell_rcfile=1
		shell_rcfile_permission="600"
		shell_rcfile_file_type_tests="rw"

		#validate if shell_rcfile_parent_dir is a whitelisted path under TERMUX_FILES
		tudo_validate_path_is_a_whitelisted_path_under_termux_files "${shell_label}_RCFILE_PARENT_DIR" "$shell_rcfile_parent_dir"
			return_value=$?
		if [ $return_value -ne 0 ] && [ $return_value -ne 2 ] &&  [ $return_value -ne 3 ]; then
			return $return_value
		fi

		validation_result=$return_value

		#if shell_rcfile_parent_dir is a whitelisted path under TERMUX_FILES
		if [ $validation_result -eq 0 ]; then
			shell_rcfile_parent_dir_ownership="--reference=\"$TERMUX_FILES\""
			shell_rcfile_ownership="--reference=\"$TERMUX_FILES\""
		#if shell_rcfile_parent_dir is a blacklisted path under TERMUX_FILES or is not under TERMUX_FILES
		else
			tudo_log_errors "The \"$shell_rcfile_parent_dir\" cannot be used as ${shell_label}_RCFILE_PARENT_DIR"
			return 1
		fi
	fi



	#if shell_automatically_create_history_files is not enabled or dry_run_tudo is enabled, then unset shell_histfile
	if [[ "$shell_automatically_create_history_file" != "1" ]] || [[ "$dry_run_tudo" == "1" ]]; then
		shell_histfile=""
	fi

	#if shell_histfile is set
	if [ ! -z "$shell_histfile" ]; then

		#if shell_histfile_parent_dir is not the same as shell_home or one of subdirectories
		if [[ "$shell_histfile_parent_dir" != "$shell_home" ]] && [[ "$shell_histfile_parent_dir" != "$shell_home"/* ]]; then
			tudo_log_errors "The ${shell_label}_HISTFILE_PARENT_DIR \"$shell_histfile_parent_dir\" must be same as ${shell_label}_HOME \"$shell_home\" or be one of its subdirectories"
			return 1
		fi

		create_shell_histfile_parent_dir_if_it_does_not_exist=1
		only_set_perms_and_ownership_on_creation_of_shell_histfile_parent_dir=1
		shell_histfile_parent_dir_permission="700"
		shell_histfile_parent_dir_file_type_tests="rwx"

		create_shell_histfile_if_it_does_not_exist=1
		only_set_perms_and_ownership_on_creation_of_shell_histfile=1
		shell_histfile_permission="600"
		shell_histfile_file_type_tests="rw"

		#validate if shell_histfile_parent_dir is a whitelisted path under TERMUX_FILES
		tudo_validate_path_is_a_whitelisted_path_under_termux_files "${shell_label}_HISTFILE_PARENT_DIR" "$shell_histfile_parent_dir"
		return_value=$?
		if [ $return_value -ne 0 ] && [ $return_value -ne 2 ] &&  [ $return_value -ne 3 ]; then
			return $return_value
		fi

		validation_result=$return_value

		#if shell_histfile_parent_dir is a whitelisted path under TERMUX_FILES
		if [ $validation_result -eq 0 ]; then
			shell_histfile_parent_dir_ownership="--reference=\"$TERMUX_FILES\""
			shell_histfile_ownership="--reference=\"$TERMUX_FILES\""
		#if shell_histfile_parent_dir is a blacklisted path under TERMUX_FILES or is not under TERMUX_FILES
		else
			tudo_log_errors "The \"$shell_histfile_parent_dir\" cannot be used as ${shell_label}_HISTFILE_PARENT_DIR"
			return 1
		fi
	fi



	tudo_create_shell_home "$shell_label" \
        "$shell_home" "$create_shell_home_if_it_does_not_exist" "$only_set_perms_and_ownership_on_creation_of_shell_home" "$shell_home_ownership" "$shell_home_permission" "$shell_home_file_type_tests" \
        "$shell_rcfile_parent_dir" "$create_shell_rcfile_parent_dir_if_it_does_not_exist" "$only_set_perms_and_ownership_on_creation_of_shell_rcfile_parent_dir" "$shell_rcfile_parent_dir_ownership" "$shell_rcfile_parent_dir_permission" "$shell_rcfile_parent_dir_file_type_tests" \
        "$shell_rcfile" "$create_shell_rcfile_if_it_does_not_exist" "$shell_rcfile_value" "$only_set_perms_and_ownership_on_creation_of_shell_rcfile" "$shell_rcfile_ownership" "$shell_rcfile_permission" "$shell_rcfile_file_type_tests" \
        "$shell_histfile_parent_dir" "$create_shell_histfile_parent_dir_if_it_does_not_exist" "$only_set_perms_and_ownership_on_creation_of_shell_histfile_parent_dir" "$shell_histfile_parent_dir_ownership" "$shell_histfile_parent_dir_permission" "$shell_histfile_parent_dir_file_type_tests" \
        "$shell_histfile" "$create_shell_histfile_if_it_does_not_exist" "$only_set_perms_and_ownership_on_creation_of_shell_histfile" "$shell_histfile_ownership" "$shell_histfile_permission" "$shell_histfile_file_type_tests"
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failure while running \"tudo_create_shell_home\""
		return $return_value
	fi

	return 0

}

#tudo_create_shell_home shell_label
#shell_home create_shell_home_if_it_does_not_exist only_set_perms_and_ownership_on_creation_of_shell_home shell_home_ownership shell_home_permission shell_home_file_type_tests
#shell_rcfile_parent_dir create_shell_rcfile_parent_dir_if_it_does_not_exist only_set_perms_and_ownership_on_creation_of_shell_rcfile_parent_dir shell_rcfile_parent_dir_ownership shell_rcfile_parent_dir_permission shell_rcfile_parent_dir_file_type_tests
#shell_rcfile create_shell_rcfile_if_it_does_not_exist shell_rcfile_value only_set_perms_and_ownership_on_creation_of_shell_rcfile shell_rcfile_ownership shell_rcfile_permission shell_rcfile_file_type_tests
#shell_histfile_parent_dir create_shell_histfile_parent_dir_if_it_does_not_exist only_set_perms_and_ownership_on_creation_of_shell_histfile_parent_dir shell_histfile_parent_dir_ownership shell_histfile_parent_dir_permission shell_histfile_parent_dir_file_type_tests
#shell_histfile create_shell_histfile_if_it_does_not_exist only_set_perms_and_ownership_on_creation_of_shell_histfile shell_histfile_ownership shell_histfile_permission shell_histfile_file_type_tests
tudo_create_shell_home() {

	local return_value

	#if parameter count is not 32
	if [ $# -ne 32 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_create_shell_home\""
		return 1
	fi

	local shell_label="$1"

	local shell_home="$2"
	local create_shell_home_if_it_does_not_exist="$3"
	local only_set_perms_and_ownership_on_creation_of_shell_home="$4"
	local shell_home_ownership="$5"
	local shell_home_permission="$6"
	local shell_home_file_type_tests="$7"


	local shell_rcfile_parent_dir="$8"
	local create_shell_rcfile_parent_dir_if_it_does_not_exist="$9"
	local only_set_perms_and_ownership_on_creation_of_shell_rcfile_parent_dir="${10}"
	local shell_rcfile_parent_dir_ownership="${11}"
	local shell_rcfile_parent_dir_permission="${12}"
	local shell_rcfile_parent_dir_file_type_tests="${13}"


	local shell_rcfile="${14}"
	local create_shell_rcfile_if_it_does_not_exist="${15}"
	local shell_rcfile_value="${16}"
	local only_set_perms_and_ownership_on_creation_of_shell_rcfile="${17}"
	local shell_rcfile_ownership="${18}"
	local shell_rcfile_permission="${19}"
	local shell_rcfile_file_type_tests="${20}"


	local shell_histfile_parent_dir="${21}"
	local create_shell_histfile_parent_dir_if_it_does_not_exist="${22}"
	local only_set_perms_and_ownership_on_creation_of_shell_histfile_parent_dir="${23}"
	local shell_histfile_parent_dir_ownership="${24}"
	local shell_histfile_parent_dir_permission="${25}"
	local shell_histfile_parent_dir_file_type_tests="${26}"

	local shell_histfile="${27}"
	local create_shell_histfile_if_it_does_not_exist="${28}"
	local only_set_perms_and_ownership_on_creation_of_shell_histfile="${29}"
	local shell_histfile_ownership="${30}"
	local shell_histfile_permission="${31}"
	local shell_histfile_file_type_tests="${32}"



	#create shell_home if missing and set ownership and permissions
	#tudo_create_modify_validate_directory directory_path_label directory_path check_if_absolute_path create_directory_if_it_does_not_exist only_set_perms_and_ownership_on_creation directory_chown_command_options directory_chmod_command_options sub_directories_chown_command_options sub_directories_chmod_command_options sub_files_chown_command_options sub_files_chmod_command_options file_type_tests
	tudo_create_modify_validate_directory "${shell_label}_HOME" "$shell_home" 1 "$create_shell_home_if_it_does_not_exist" "$only_set_perms_and_ownership_on_creation_of_shell_home" "$shell_home_ownership" "$shell_home_permission" - - - - "$shell_home_file_type_tests" || return $?



	#if shell_rcfile is set
	if [ ! -z "$shell_rcfile" ]; then
		#if shell_home and shell_rcfile_parent_dir are not same
		if [[ "$shell_home" != "$shell_rcfile_parent_dir" ]]; then
			#create shell_rcfile_parent_dir if missing and set ownership and permissions
			#tudo_create_modify_validate_directory directory_path_label directory_path check_if_absolute_path create_directory_if_it_does_not_exist directory_chown_command_options directory_chmod_command_options sub_directories_chown_command_options sub_directories_chmod_command_options sub_files_chown_command_options sub_files_chmod_command_options file_type_tests
			tudo_create_modify_validate_directory "${shell_label}_RCFILE_PARENT_DIR" "$shell_rcfile_parent_dir" 1 "$create_shell_rcfile_parent_dir_if_it_does_not_exist" "$only_set_perms_and_ownership_on_creation_of_shell_rcfile_parent_dir" "$shell_rcfile_parent_dir_ownership" "$shell_rcfile_parent_dir_permission" - - - - "$shell_rcfile_parent_dir_file_type_tests" || return $?
		fi

		#create shell_rcfile if missing and set ownership and permissions
		#tudo_create_modify_validate_file file_path_label file_path check_if_absolute_path create_file_if_it_does_not_exist file_creation_command_options file_content only_set_perms_and_ownership_on_creation file_chown_command_options file_chmod_command_options file_type_tests
		tudo_create_modify_validate_file "${shell_label}_RCFILE" "$shell_rcfile" 1 "$create_shell_rcfile_if_it_does_not_exist" "%s" "$shell_rcfile_value" "$only_set_perms_and_ownership_on_creation_of_shell_rcfile" "$shell_rcfile_ownership" "$shell_rcfile_permission" "$shell_rcfile_file_type_tests" || return $?
	fi



	#if shell_histfile is set
	if [ ! -z "$shell_histfile" ]; then
		#if shell_home and shell_histfile_parent_dir are not same
		#and shell_rcfile_parent_dir shell_histfile_parent_dir are not same
		if [[ "$shell_home" != "$shell_histfile_parent_dir" ]] && [[ "$shell_rcfile_parent_dir" != "$shell_histfile_parent_dir" ]]; then
			#create shell_histfile_parent_dir if missing and set ownership and permissions
			#tudo_create_modify_validate_directory directory_path_label directory_path check_if_absolute_path create_directory_if_it_does_not_exist directory_chown_command_options directory_chmod_command_options sub_directories_chown_command_options sub_directories_chmod_command_options sub_files_chown_command_options sub_files_chmod_command_options file_type_tests
			tudo_create_modify_validate_directory "${shell_label}_HISTFILE_PARENT_DIR" "$shell_histfile_parent_dir" 1 "$create_shell_histfile_parent_dir_if_it_does_not_exist" "$only_set_perms_and_ownership_on_creation_of_shell_histfile_parent_dir" "$shell_histfile_parent_dir_ownership" "$shell_histfile_parent_dir_permission" - - - - "$shell_histfile_parent_dir_file_type_tests" || return $?
		fi

		#create shell_histfile if missing and set ownership and permissions
		#tudo_create_modify_validate_file file_path_label file_path check_if_absolute_path create_file_if_it_does_not_exist file_creation_command_options file_content only_set_perms_and_ownership_on_creation file_chown_command_options file_chmod_command_options file_type_tests
		tudo_create_modify_validate_file "${shell_label}_HISTFILE" "$shell_histfile" 1 "$create_shell_histfile_if_it_does_not_exist" "%s" "" "$only_set_perms_and_ownership_on_creation_of_shell_histfile" "$shell_histfile_ownership" "$shell_histfile_permission" "$shell_histfile_file_type_tests" || return $?
	fi

	return 0

}

tudo_setup_termux_tmp_dir() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_setup_termux_tmp_dir"

	local create_termux_tmp_dir_if_it_does_not_exist
	local only_set_perms_and_ownership_on_creation_of_termux_tmp_dir
	local termux_tmp_dir_permission
	local termux_tmp_dir_ownership
	local termux_tmp_dir_file_type_tests

	create_termux_tmp_dir_if_it_does_not_exist=1
	only_set_perms_and_ownership_on_creation_of_termux_tmp_dir=1
	termux_tmp_dir_permission="700"
	termux_tmp_dir_ownership="--reference='$TERMUX_PREFIX'"
	termux_tmp_dir_file_type_tests="drwx"


	#create TUDO_SHELL_WORKING_DIR if missing
	#tudo_create_modify_validate_directory directory_path_label directory_path check_if_absolute_path create_directory_if_it_does_not_exist only_set_perms_and_ownership_on_creation directory_chown_command_options directory_chmod_command_options sub_directories_chown_command_options sub_directories_chmod_command_options sub_files_chown_command_options sub_files_chmod_command_options file_type_tests
	tudo_create_modify_validate_directory "TMPDIR" "$TMPDIR" 1 "$create_termux_tmp_dir_if_it_does_not_exist" "$only_set_perms_and_ownership_on_creation_of_termux_tmp_dir" "$termux_tmp_dir_ownership" "$termux_tmp_dir_permission" - - - - "$termux_tmp_dir_file_type_tests" || return $?

	return 0

}

tudo_set_tudo_shell_working_dir() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_tudo_shell_working_dir"

	#replace "$PREFIX/" or "~/" prefix with termux absolute paths in TUDO_SHELL_WORKING_DIR
	tudo_expand_termux_path "TUDO_SHELL_WORKING_DIR" "TUDO_SHELL_WORKING_DIR" "$TUDO_SHELL_WORKING_DIR" "$TERMUX_PREFIX" "$TERMUX_HOME" 1
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failed to expand TUDO_SHELL_WORKING_DIR \"$TUDO_SHELL_WORKING_DIR\""
		return $return_value
	fi

	#if TUDO_SHELL_WORKING_DIR is not a valid absolute path
	if [[ ! "$TUDO_SHELL_WORKING_DIR" =~ $valid_absolute_path_regex ]]; then
		tudo_log_errors "The TUDO_SHELL_WORKING_DIR \"$TUDO_SHELL_WORKING_DIR\" is not a valid absolute path"
		return 1
	fi

	tudo_log 1 "TUDO_SHELL_WORKING_DIR=\"$TUDO_SHELL_WORKING_DIR\""

	#find the parent directory of the TUDO_SHELL_WORKING_DIR
	TUDO_SHELL_WORKING_DIR_BASENAME="${TUDO_SHELL_WORKING_DIR##*/}" #strip longest match of */ from start
	TUDO_SHELL_WORKING_DIR_PARENT_DIR="${TUDO_SHELL_WORKING_DIR:0:${#TUDO_SHELL_WORKING_DIR} - ${#TUDO_SHELL_WORKING_DIR_BASENAME}}" #substring from 0 to position of basename
	case $TUDO_SHELL_WORKING_DIR_PARENT_DIR in *[!/]*/) TUDO_SHELL_WORKING_DIR_PARENT_DIR=${TUDO_SHELL_WORKING_DIR_PARENT_DIR%"${TUDO_SHELL_WORKING_DIR_PARENT_DIR##*[!/]}"};; *[/]) TUDO_SHELL_WORKING_DIR_PARENT_DIR="/";; esac #remove trailing slashes if not root

	tudo_log 2 "TUDO_SHELL_WORKING_DIR_PARENT_DIR=\"$TUDO_SHELL_WORKING_DIR_PARENT_DIR\""

	return 0

}

tudo_setup_tudo_shell_working_dir() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_setup_tudo_shell_working_dir"

	local create_shell_working_dir_if_it_does_not_exist
	local only_set_perms_and_ownership_on_creation_of_shell_working_dir
	local shell_working_dir_permission
	local shell_working_dir_ownership
	local shell_working_dir_file_type_tests

	create_shell_working_dir_if_it_does_not_exist=1
	only_set_perms_and_ownership_on_creation_of_shell_working_dir=1
	shell_working_dir_permission="700"

	#find the parent directory of the TUDO_SHELL_WORKING_DIR
	TUDO_SHELL_WORKING_DIR_BASENAME="${TUDO_SHELL_WORKING_DIR##*/}" #strip longest match of */ from start
	TUDO_SHELL_WORKING_DIR_PARENT_DIR="${TUDO_SHELL_WORKING_DIR:0:${#TUDO_SHELL_WORKING_DIR} - ${#TUDO_SHELL_WORKING_DIR_BASENAME}}" #substring from 0 to position of basename
	case $TUDO_SHELL_WORKING_DIR_PARENT_DIR in *[!/]*/) TUDO_SHELL_WORKING_DIR_PARENT_DIR=${TUDO_SHELL_WORKING_DIR_PARENT_DIR%"${TUDO_SHELL_WORKING_DIR_PARENT_DIR##*[!/]}"};; *[/]) TUDO_SHELL_WORKING_DIR_PARENT_DIR="/";; esac #remove trailing slashes if not root

	shell_working_dir_ownership="--reference='${TUDO_SHELL_WORKING_DIR_PARENT_DIR//\'/\'\\\'\'}'"


	#if TUDO_SHELL_WORKING_DIR is the same as TERMUX_FILES or is under it
	if [[ "$TUDO_SHELL_WORKING_DIR" == "$TERMUX_FILES" ]] || [[ "$TUDO_SHELL_WORKING_DIR" == "$TERMUX_FILES"/* ]]; then
		shell_working_dir_file_type_tests="drwx"
	#it might not be possible for the directory to be writable or executable in other paths like in storage
	else
		shell_working_dir_file_type_tests="dr"
	fi


	#create TUDO_SHELL_WORKING_DIR if missing
	#tudo_create_modify_validate_directory directory_path_label directory_path check_if_absolute_path create_directory_if_it_does_not_exist only_set_perms_and_ownership_on_creation directory_chown_command_options directory_chmod_command_options sub_directories_chown_command_options sub_directories_chmod_command_options sub_files_chown_command_options sub_files_chmod_command_options file_type_tests
	tudo_create_modify_validate_directory "TUDO_SHELL_WORKING_DIR" "$TUDO_SHELL_WORKING_DIR" 1 "$create_shell_working_dir_if_it_does_not_exist" "$only_set_perms_and_ownership_on_creation_of_shell_working_dir" "$shell_working_dir_ownership" "$shell_working_dir_permission" - - - - "$shell_working_dir_file_type_tests" || return $?

	return 0

}

tudo_set_tudo_temp_directory_parent_directory() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_set_tudo_temp_directory_parent_directory"

	#use TMPDIR as TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY
	TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY="$TMPDIR"

	#if TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY is not a valid absolute path
	if [[ ! "$TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY" =~ $valid_absolute_path_regex ]]; then
		tudo_log_errors "The TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY \"$TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY\" is not a valid absolute path"
		return 1
	fi

	#if TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY is not set to an absolute path under TERMUX_FILES
	if [[ ! "$TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY" =~ $valid_path_under_termux_files_regex ]]; then
		tudo_log_errors "The TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY \"$TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY\" must be an absolute path under TERMUX_FILES \"$TERMUX_FILES\""
	fi

	#if TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY is an absolute path under TERMUX_HOME
	if [[ "$TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY" =~ $valid_path_under_termux_home_regex ]]; then
		tudo_log_errors "The TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY \"$TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY\" must not be an absolute path under TERMUX_HOME \"$TERMUX_HOME\""
	fi

	#if remove_previous_tudo_temp_files is enabled
	if [[ "$remove_previous_tudo_temp_files" == "1" ]]; then
		#if TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY is set to an absolute path and TUDO_TEMP_DIRECTORY_PREFIX is not empty
		if [[ "$TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY" =~ $valid_absolute_path_regex ]] && [ ! -z "$TUDO_TEMP_DIRECTORY_PREFIX" ]; then
			#remove all directories with the prefix TUDO_TEMP_DIRECTORY_PREFIX
			tudo_log_literal 2 "\nRemove all directories with the prefix \"$TUDO_TEMP_DIRECTORY_PREFIX\" in TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY \"$TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY\""
			find "$TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY" -maxdepth 1 -type d -name "$TUDO_TEMP_DIRECTORY_PREFIX*" -exec rm -rf "{}" \;
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "Failure while removing all directories with the prefix \"$TUDO_TEMP_DIRECTORY_PREFIX\" in TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY \"$TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY\""
				return $return_value
			fi
		fi
	fi

	#tudo_log 2 "TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY=\"$TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY\""

	return 0

}

tudo_setup_tudo_temp_directory() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_setup_tudo_temp_directory"

	local create_shell_tudo_temp_dir_parent_dir_if_it_does_not_exist
	local only_set_perms_and_ownership_on_creation_of_shell_tudo_temp_dir_parent_dir
	local shell_tudo_temp_dir_parent_dir_permission
	local shell_tudo_temp_dir_parent_dir_ownership
	local shell_tudo_temp_dir_parent_dir_file_type_tests

	create_shell_tudo_temp_dir_parent_dir_if_it_does_not_exist=1
	only_set_perms_and_ownership_on_creation_of_shell_tudo_temp_dir_parent_dir=1
	shell_tudo_temp_dir_parent_dir_permission="700"
	shell_tudo_temp_dir_parent_dir_ownership="--reference=\"$TERMUX_FILES\""
	shell_tudo_temp_dir_parent_dir_file_type_tests="drwx"

	#create TUDO_SHELL_WORKING_DIR if missing
	#tudo_create_modify_validate_directory directory_path_label directory_path check_if_absolute_path create_directory_if_it_does_not_exist only_set_perms_and_ownership_on_creation directory_chown_command_options directory_chmod_command_options sub_directories_chown_command_options sub_directories_chmod_command_options sub_files_chown_command_options sub_files_chmod_command_options file_type_tests
	tudo_create_modify_validate_directory "TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY" "$TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY" 1 "$create_shell_tudo_temp_dir_parent_dir_if_it_does_not_exist" "$only_set_perms_and_ownership_on_creation_of_shell_tudo_temp_dir_parent_dir" "$shell_tudo_temp_dir_parent_dir_ownership" "$shell_tudo_temp_dir_parent_dir_permission" - - - - "$shell_tudo_temp_dir_parent_dir_file_type_tests" || return $?


	#create a temp directory in TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY to store temp scripts used by the tudo script
	#TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY by default would be same as TMPDIR
	#TMPDIR is used since obv thats what its for, duh!
	#moreover termux will automatically remove the temp directory when its sessions are closed if it was not
	# automatically removed at the end of tudo execution and left there
	#the temp directory must be under TERMUX_FILES so that it can be created by the termux user
	#the temp directory must not be under TERMUX_HOME since other apps with SAF access can access it
	#a directory is created to store script files since if '--script-name' is passed, then there may
	#be conflicts between executions since temp files will share the same parent directory and have the same name
	#this will allow each execution of the script to have a separate directory for itself with a random suffix
	#scripts will also have an empty directory to use that will be unique for them, which will be removed after execution
	TUDO_TEMP_DIRECTORY="$(mktemp -d --tmpdir="$TUDO_TEMP_DIRECTORY_PARENT_DIRECTORY" "$TUDO_TEMP_DIRECTORY_PREFIX.XXXXXX")"
	return_value=$?
	if [ $return_value -ne 0 ] || [[ ! "$TUDO_TEMP_DIRECTORY" =~ $valid_absolute_path_regex ]]; then
		tudo_log_errors "Failure while running mktemp to create TUDO_TEMP_DIRECTORY"
		tudo_log_errors "TUDO_TEMP_DIRECTORY=\"$TUDO_TEMP_DIRECTORY\""
		if [ $return_value -eq 0 ]; then
			return_value=1
		fi
		return $return_value
	fi

	return 0

}

set_tudo_traps() {

	#set traps for the tudo itself
	trap 'tudo_trap' EXIT
	trap 'tudo_trap TERM' TERM
	trap 'tudo_trap INT' INT
	trap 'tudo_trap HUP' HUP
	trap 'tudo_trap QUIT' QUIT

	return 0

}

tudo_trap() {

	#the tudo_trap will do the following:
	#store the original trap signal in $tudo_exit_code
	#remove the EXIT trap so its not called again
	#remove temp_directory if set if tudo command failed
	#if a signal argument was passed, then remove its trap and
	#then exit with the original trap signal exit code
	#so that parent processes can be notified if necessary

	local tudo_exit_code=$?
	trap - EXIT

	[ $tudo_exit_code -ne 0 ] && tudo_remove_tudo_temp_directory

	[ -n "$1" ] && trap - $1; exit $tudo_exit_code

}

tudo_remove_tudo_temp_directory() {

	#if TUDO_TEMP_DIRECTORY is a valid absolute path and
	#do_not_delete_tudo_temp_directory_on_exit is not enabled
	if [[ "$TUDO_TEMP_DIRECTORY" =~ $valid_absolute_path_regex ]] && \
		[[ "$do_not_delete_tudo_temp_directory_on_exit" != "1" ]]; then
		#remove TUDO_TEMP_DIRECTORY in case it wasn't already removed
		tudo_log_literal 2 "\nRemoving TUDO_TEMP_DIRECTORY in case it wasn't already removed"
		rm -rf "$TUDO_TEMP_DIRECTORY"
		TUDO_TEMP_DIRECTORY=""
	fi

}

tudo_create_script_command_traps() {

	local return_value

	tudo_log_literal 2 "\nRunning tudo_create_script_command_traps"

	#the tudo_script_trap will do the following:
	#store the original trap signal in $tudo_script_exit_code
	#call the tudo_script_custom_trap function
	#if it exits with 0, then continue normally
	#if it exits with 125 'ECANCELED', then do not continue and just return
	#if it exits with any other exit code, store it so that we exit
	#with that instead of the original trap signal
	#remove the EXIT trap so its not called again
	#remove temp_directory if set
	#if a signal argument was passed, then remove its trap
	#send the original trap signal to all the children of the pid
	#and exit with the original trap signal exit code or that of the
	#tudo_script_custom_trap function so that parent processes can be
	#notified if necessary

	TUDO_SCRIPT_COMMAND_TRAPS=""

	#if TUDO_TEMP_DIRECTORY is a valid absolute path and do_not_delete_tudo_temp_directory_on_exit is not enabled
	if [[ "$TUDO_TEMP_DIRECTORY" =~ $valid_absolute_path_regex ]] && [[ "$do_not_delete_tudo_temp_directory_on_exit" != "1" ]]; then
		#append the function to TUDO_SCRIPT_COMMAND_TRAPS to remove TUDO_TEMP_DIRECTORY
		#this may specially be necessary if '-E' is passed
		TUDO_SCRIPT_COMMAND_TRAPS_REMOVE_TEMP_DIRECTORY_FUNCTION="tudo_remove_temp_directory"

		TUDO_SCRIPT_COMMAND_TRAPS+='
export TUDO_SCRIPT_DIR='"'${TUDO_TEMP_DIRECTORY//\'/\'\\\'\'}'"'

'"$TUDO_SCRIPT_COMMAND_TRAPS_REMOVE_TEMP_DIRECTORY_FUNCTION"'() {
    rm -rf '"'${TUDO_TEMP_DIRECTORY//\'/\'\\\'\'}'"'
}
'
	else
		TUDO_SCRIPT_COMMAND_TRAPS_REMOVE_TEMP_DIRECTORY_FUNCTION=""
	fi

	TUDO_SCRIPT_COMMAND_TRAPS+='
tudo_script_custom_trap() { :; }

tudo_script_killtree() {
    local signal="$1"; local pid="$2"; local cpid
    for cpid in $(pgrep -P "$pid"); do tudo_script_killtree "$signal" "$cpid"; done
    [[ "$pid" != "$$" ]] && signal="${signal:=15}"; kill "-$signal" "$pid" 2>/dev/null
}

tudo_script_trap() {
    local tudo_script_exit_code=$?
    local return_value; tudo_script_custom_trap "$@"; return_value=$?
    [ $return_value -eq 125 ] && return 0
    [ $return_value -ne 0 ] && tudo_script_exit_code=$return_value
    trap - EXIT '"${TUDO_SCRIPT_COMMAND_TRAPS_REMOVE_TEMP_DIRECTORY_FUNCTION:+$'\n'    $TUDO_SCRIPT_COMMAND_TRAPS_REMOVE_TEMP_DIRECTORY_FUNCTION}"'
    [ -n "$1" ] && trap - $1
    tudo_script_killtree "$1" $$; exit $tudo_script_exit_code
}
'"
trap 'tudo_script_trap' EXIT
trap 'tudo_script_trap TERM' TERM
trap 'tudo_script_trap INT' INT
trap 'tudo_script_trap HUP' HUP
trap 'tudo_script_trap QUIT' QUIT
"
	return 0

}

#tudo_run_file_type_tests_on_path label path log_file_tests_failure_errors show_stat_output_on_file_tests_failure check_if_absolute_path file_type_tests
tudo_run_file_type_tests_on_path() {

	local return_value

	#if parameter count is not 6
	if [ $# -ne 6 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_run_file_type_tests_on_path\""
		return 1
	fi

	local label="$1"
	local path="$2"
	local log_file_tests_failure_errors="$3"
	local show_stat_output_on_file_tests_failure="$4"
	local check_if_absolute_path="$5"
	local file_type_tests="$6"

	#if file_type_tests is invalid
	if [[ ! "$file_type_tests" =~ ^[bcdefgGkhLOprSsuwx]+$ ]]; then
		tudo_log_errors "file_type_tests \"$file_type_tests\" passed to \"tudo_run_file_type_tests_on_path\" is not valid"
		return 1
	fi

	#if check_if_absolute_path is enabled and path is not a valid absolute path
	local valid_absolute_path_regex='^(/[^/]+)+$'
	if [[ "$check_if_absolute_path" == "1" ]] && [[ ! "$path" =~ $valid_absolute_path_regex ]]; then
		tudo_log_errors "The \"$label\" file \"$path\" is not an absolute path"
		return 2
	fi

	local command=""

	for (( i=0; i<${#file_type_tests}; i++ )); do
		file_type_test="${file_type_tests:$i:1}"

		[[ ! -z "$command" ]] && command+=" && "
		command+="test -$file_type_test '${path//\'/\'\\\'\'}'" #replace any single quotes `'` with `'\''` to maintain quoting and prevent arbitrary command execution with eval
	done

	#if command is empty
	if [[ -z "$command" ]]; then
		return 0
	fi

	#run all tests
	#0 means success, 1 means failure, other exit codes mean some other error
	eval "$command"
	return_value=$?
	if [ $return_value -eq 0 ]; then
		return 0
	fi

	if [ $return_value -ne 1 ] || \
		([ $return_value -eq 1 ] && [[ "$log_file_tests_failure_errors" == "1" ]]); then
		local file_type_tests_label=""

		declare -A file_type_tests_labels=(
			["b"]="[block special device]"
			["c"]="[character special device]"
			["d"]="[directory]"
			["e"]="[exists]"
			["f"]="[regular file]"
			["g"]="[set-group-id bit set]"
			["G"]="[owned by the current effective group id]"
			["k"]="[sticky bit set]"
			["h"]="[symbolic link]"
			["L"]="[symbolic link]"
			["O"]="[owned by the current effective user id]"
			["p"]="[pipe]"
			["r"]="[readable]"
			["S"]="[socket]"
			["s"]="[size greater than zero]"
			["u"]="[set-user-id bit set]"
			["w"]="[writable]"
			["x"]="[executable]"
		)

		for (( i=0; i<${#file_type_tests}; i++ )); do
			file_type_test="${file_type_tests:$i:1}"

			[[ ! -z "$file_type_tests_label" ]] && file_type_tests_label+=", "
			file_type_tests_label+="${file_type_tests_labels[$file_type_test]}"
		done
	fi

	if [ $return_value -ne 1 ]; then
		tudo_log_errors "Failed to run the following test types on the file \"$label\" at path \"$path\": $file_type_tests_label"
	else
		if [[ "$log_file_tests_failure_errors" == "1" ]]; then
			tudo_log_errors "The \"$label\" file at path \"$path\" failed one or more of the following test types: $file_type_tests_label"
			if [[ "$show_stat_output_on_file_tests_failure" == "1" ]]; then
				current_user_id="$(id -u 2>/dev/null)"
				current_user_name="$(id -un 2>/dev/null)"
				stat_output="$(stat --format="file type: %F"$'\n'"access: %A (%a)"$'\n'"owner: %U (%u)"$'\n'"group: %G (%g)"$'\n'"selinux context: %C"$'\n'"size: %s" "$path" 2>/dev/null)"
				#if stat_output is not empty
				if [[ ! -z "$stat_output" ]]; then
					tudo_log_errors "current user: $current_user_name ($current_user_id)"$'\n'"$stat_output"
				fi
			fi
		fi
	fi

	return $return_value

}

#tudo_create_modify_validate_directory directory_path_label directory_path check_if_absolute_path create_directory_if_it_does_not_exist only_set_perms_and_ownership_on_creation directory_chown_command_options directory_chmod_command_options sub_directories_chown_command_options sub_directories_chmod_command_options sub_files_chown_command_options sub_files_chmod_command_options file_type_tests
tudo_create_modify_validate_directory() {

	local return_value

	#if parameter count is not 12
	if [ $# -ne 12 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_create_modify_validate_directory\""
		return 1
	fi

	#tudo_log_literal 2 "\nRunning tudo_create_modify_validate_directory"

	local directory_path_label="$1"
	local directory_path="$2"
	local check_if_absolute_path="$3"
	local create_directory_if_it_does_not_exist="$4"
	local only_set_perms_and_ownership_on_creation="$5"
	local directory_chown_command_options="$6"
	local directory_chmod_command_options="$7"
	local sub_directories_chown_command_options="$8"
	local sub_directories_chmod_command_options="$9"
	local sub_files_chown_command_options="${10}"
	local sub_files_chmod_command_options="${11}"
	local file_type_tests="${12}"

	local directory_created=0

	#if create_directory_if_it_does_not_exist is not set to 0 or 1
	if [[ "$create_directory_if_it_does_not_exist" != "0" ]] && [[ "$create_directory_if_it_does_not_exist" != "1" ]]; then
		tudo_log_errors "create_directory_if_it_does_not_exist \"$create_directory_if_it_does_not_exist\" passed to \"tudo_create_modify_validate_directory\" is not equal to \"0\" or \"1\""
		return 1
	fi

	#if only_set_perms_and_ownership_on_creation is not set to 0 or 1
	if [[ "$only_set_perms_and_ownership_on_creation" != "0" ]] && [[ "$only_set_perms_and_ownership_on_creation" != "1" ]]; then
		tudo_log_errors "only_set_perms_and_ownership_on_creation \"$only_set_perms_and_ownership_on_creation\" passed to \"tudo_create_modify_validate_directory\" is not equal to \"0\" or \"1\""
		return 1
	fi

	#if check_if_absolute_path is enabled and directory_path is not a valid absolute path
	local valid_absolute_path_regex='^(/[^/]+)+$'
	if [[ "$check_if_absolute_path" == "1" ]] && [[ ! "$directory_path" =~ $valid_absolute_path_regex ]]; then
		tudo_log_errors "The \"$directory_path_label\" directory \"$directory_path\" is not an absolute path"
		return 2
	fi

	#check if a non-directory file exists at directory path
	if [ -e "$directory_path" ] && [ ! -d "$directory_path" ]; then
		tudo_log_errors "A non-directory file exists at $directory_path_label \"$directory_path\""
		return 1
	fi

	#if directory does not exist
	if [ ! -d "$directory_path" ]; then
		#if create_directory_if_it_does_not_exist is enabled, then create directory
		if [[ "$create_directory_if_it_does_not_exist" == "1" ]]; then
			tudo_log 2 "Creating $directory_path_label directory at \"$directory_path\""
			mkdir -p "$directory_path"
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "Failed to create $directory_path_label directory at \"$directory_path\""
				return $return_value
			fi

			directory_created=1
		fi
	else
		tudo_log 2 "The $directory_path_label directory already exists at \"$directory_path\""
	fi

	#check if directory did not already exist or was not created successfully
	if [ ! -d "$directory_path" ]; then
		tudo_log_errors "Failed to find $directory_path_label directory at \"$directory_path\""
		return 1
	fi

	#if only_set_perms_and_ownership_on_creation is enabled and directory was not created
	if  [[ "$only_set_perms_and_ownership_on_creation" == "1" ]] && [[ "$directory_created" == "0" ]]; then
		tudo_log 2 "Skipping setting ownership and permission for $directory_path_label directory since it was not created"
	else

		#set directory ownership
		if [[ "$directory_chown_command_options" != "-" ]]; then
			IFS=$'\n'
			local -a directory_chown_command_options_array=( $(xargs -r -n1 -- printf -- "%s\n" <<< "$directory_chown_command_options") )
			IFS=$' \t\n'
			tudo_log 2 "Setting \"${directory_chown_command_options_array[*]}\" ownership to $directory_path_label directory at \"$directory_path\" directory"
			chown "${directory_chown_command_options_array[@]}" "$directory_path"
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "Failed to set ownership of $directory_path_label directory at \"$directory_path\""
				return $return_value
			fi
		fi

		#set directory permissions
		if [[ "$directory_chmod_command_options" != "-" ]]; then
			IFS=$'\n'
			local -a directory_chmod_command_options_array=( $(xargs -r -n1 -- printf -- "%s\n" <<< "$directory_chmod_command_options") )
			IFS=$' \t\n'
			tudo_log 2 "Setting \"${directory_chmod_command_options_array[*]}\" permissions to $directory_path_label directory at \"$directory_path\" directory"
			chmod "${directory_chmod_command_options_array[@]}" "$directory_path"
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "Failed to set permissions of $directory_path_label directory at \"$directory_path\""
				return $return_value
			fi
		fi

		#set subdirectories ownership
		if [[ "$sub_directories_chown_command_options" != "-" ]]; then
			IFS=$'\n'
			local -a sub_directories_chown_command_options_array=( $(xargs -r -n1 -- printf -- "%s\n" <<< "$sub_directories_chown_command_options") )
			IFS=$' \t\n'
			tudo_log 2 "Setting \"${sub_directories_chown_command_options_array[*]}\" ownership to $directory_path_label directory at \"$directory_path\" subdirectories"
			find "$directory_path" -type d -print0 | xargs -0 -r -- chown "${sub_directories_chown_command_options_array[@]}" --
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "Failed to set ownership of subdirectories in $directory_path_label directory at \"$directory_path\""
				return $return_value
			fi
		fi

		#set subdirectories permissions
		if [[ "$sub_directories_chmod_command_options" != "-" ]]; then
			IFS=$'\n'
			local -a sub_directories_chmod_command_options_array=( $(xargs -r -n1 -- printf -- "%s\n" <<< "$sub_directories_chmod_command_options") )
			IFS=$' \t\n'
			tudo_log 2 "Setting \"${sub_directories_chmod_command_options_array[*]}\" permissions to $directory_path_label directory at \"$directory_path\" subdirectories"
			find "$directory_path" -type d -print0 | xargs -0 -r -- chmod "${sub_directories_chmod_command_options_array[@]}" --
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "Failed to set permissions of subdirectories in $directory_path_label directory at \"$directory_path\""
				return $return_value
			fi
		fi

		#set subfiles ownership
		if [[ "$sub_files_chown_command_options" != "-" ]]; then
			IFS=$'\n'
			local -a sub_files_chown_command_options_array=( $(xargs -r -n1 -- printf -- "%s\n" <<< "$sub_files_chown_command_options") )
			IFS=$' \t\n'
			tudo_log 2 "Setting \"${sub_files_chown_command_options_array[*]}\" ownership to $directory_path_label directory at \"$directory_path\" subfiles"
			find "$directory_path" -type f -print0 | xargs -0 -r -- chown "${sub_files_chown_command_options_array[@]}" --
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "Failed to set ownership of subfiles in $directory_path_label directory at \"$directory_path\""
				return $return_value
			fi
		fi

		#set subfiles permissions
		if [[ "$sub_files_chmod_command_options" != "-" ]]; then
			IFS=$'\n'
			local -a sub_files_chmod_command_options_array=( $(xargs -r -n1 -- printf -- "%s\n" <<< "$sub_files_chmod_command_options") )
			IFS=$' \t\n'
			tudo_log 2 "Setting \"${sub_files_chmod_command_options_array[*]}\" permissions to $directory_path_label directory at \"$directory_path\" subfiles"
			find "$directory_path" -type f -print0 | xargs -0 -r -- chmod "${sub_files_chmod_command_options_array[@]}" --
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "Failed to set permissions of subfiles in $directory_path_label directory at \"$directory_path\""
				return $return_value
			fi
		fi
	fi


	#run file type tests with test command
	if [[ "$file_type_tests" != "-" ]]; then
		#tudo_run_file_type_tests_on_path label path log_file_tests_failure_errors show_stat_output_on_file_tests_failure check_if_absolute_path file_type_tests
		tudo_run_file_type_tests_on_path "$directory_path_label" "$directory_path" 1 1 0 "$file_type_tests" || return $?
	fi


	return 0

}

#tudo_create_modify_validate_file file_path_label file_path check_if_absolute_path create_file_if_it_does_not_exist file_creation_command_options file_content only_set_perms_and_ownership_on_creation file_chown_command_options file_chmod_command_options file_type_tests
tudo_create_modify_validate_file() {

	local return_value

	#if parameter count is not 10
	if [ $# -ne 10 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_create_modify_validate_file\""
		return 1
	fi

	#tudo_log_literal 2 "\nRunning tudo_create_modify_validate_file"

	local file_path_label="$1"
	local file_path="$2"
	local check_if_absolute_path="$3"
	local create_file_if_it_does_not_exist="$4"
	local file_creation_command_options="$5"
	local file_content="$6"
	local only_set_perms_and_ownership_on_creation="$7"
	local file_chown_command_options="$8"
	local file_chmod_command_options="$9"
	local file_type_tests="${10}"

	local file_created=0

	#if create_file_if_it_does_not_exist is not set to 0 or 1
	if [[ "$create_file_if_it_does_not_exist" != "0" ]] && [[ "$create_file_if_it_does_not_exist" != "1" ]]; then
		tudo_log_errors "create_file_if_it_does_not_exist \"$create_file_if_it_does_not_exist\" passed to \"tudo_create_modify_validate_file\" is not equal to \"0\" or \"1\""
		return 1
	fi

	#if only_set_perms_and_ownership_on_creation is not set to 0 or 1
	if [[ "$only_set_perms_and_ownership_on_creation" != "0" ]] && [[ "$only_set_perms_and_ownership_on_creation" != "1" ]]; then
		tudo_log_errors "only_set_perms_and_ownership_on_creation \"$only_set_perms_and_ownership_on_creation\" passed to \"tudo_create_modify_validate_file\" is not equal to \"0\" or \"1\""
		return 1
	fi

	#if check_if_absolute_path is enabled and file_path is not a valid absolute path
	local valid_absolute_path_regex='^(/[^/]+)+$'
	if [[ "$check_if_absolute_path" == "1" ]] && [[ ! "$file_path" =~ $valid_absolute_path_regex ]]; then
		tudo_log_errors "The \"$file_path_label\" file \"$file_path\" is not an absolute path"
		return 2
	fi

	#check if a non-file file exists at file path
	if [ -e "$file_path" ] && [ ! -f "$file_path" ]; then
		tudo_log_errors "A non-regular file exists at $file_path_label \"$file_path\""
		return 1
	fi

	#if it does not exist
	if [ ! -f "$file_path" ]; then
		#if create_file_if_it_does_not_exist is enabled, then create file
		if [[ "$create_file_if_it_does_not_exist" == "1" ]]; then

			tudo_log 2 "Creating $file_path_label \"$file_path\" file"
			local -a file_creation_command_options_array
			if [[ "$file_creation_command_options" != "-" ]]; then
				IFS=$'\n'
				file_creation_command_options_array=( $(xargs -r -n1 -- printf -- "%s\n" <<< "$file_creation_command_options") )
				IFS=$' \t\n'
			fi

			#if file_creation_options is set, then pass it to printf
			if [ ${#file_creation_command_options_array[@]} -ne 0 ]; then
				printf "${file_creation_command_options_array[@]}" "$file_content" > "$file_path"
			else
				printf "$file_content" > "$file_path"
			fi
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "Failed to create $file_path_label file at \"$file_path\""
				return $return_value
			fi

			file_created=1
		fi
	else
		tudo_log 2 "The $file_path_label file already exists at \"$file_path\""
	fi

	#check if file did not already exist or was not created successfully
	if [ ! -f "$file_path" ]; then
		tudo_log_errors "Failed to find $file_path_label file at \"$file_path\""
		return 1
	fi

	#if only_set_perms_and_ownership_on_creation is enabled and file was not created
	if  [[ "$only_set_perms_and_ownership_on_creation" == "1" ]] && [[ "$file_created" == "0" ]]; then
		tudo_log 2 "Skipping setting ownership and permission for $file_path_label file since it was not created"
	else
		#set file ownership
		if [[ "$file_chown_command_options" != "-" ]]; then
			IFS=$'\n'
			local -a file_chown_command_options_array=( $(xargs -r -n1 -- printf -- "%s\n" <<< "$file_chown_command_options") )
			IFS=$' \t\n'
			tudo_log 2 "Setting \"${file_chown_command_options_array[*]}\" ownership to $file_path_label \"$file_path\" file"
			chown "${file_chown_command_options_array[@]}" "$file_path"
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "Failed to set ownership of $file_path_label file at \"$file_path\""
				return $return_value
			fi
		fi

		#set file permissions
		if [[ "$file_chmod_command_options" != "-" ]]; then
			IFS=$'\n'
			local -a file_chmod_command_options_array=( $(xargs -r -n1 -- printf -- "%s\n" <<< "$file_chmod_command_options") )
			IFS=$' \t\n'
			tudo_log 2 "Setting \"${file_chmod_command_options_array[*]}\" permissions to $file_path_label \"$file_path\" file"
			chmod "${file_chmod_command_options_array[@]}" "$file_path"
			return_value=$?
			if [ $return_value -ne 0 ]; then
				tudo_log_errors "Failed to set permissions of $file_path_label file at \"$file_path\""
				return $return_value
			fi
		fi
	fi


	#run file type tests with test command
	if [[ "$file_type_tests" != "-" ]]; then
		#tudo_run_file_type_tests_on_path label path log_file_tests_failure_errors show_stat_output_on_file_tests_failure check_if_absolute_path file_type_tests
		tudo_run_file_type_tests_on_path "$file_path_label" "$file_path" 1 1 0 "$file_type_tests" || return $?
	fi


	return 0

}

#tudo_expand_termux_path variable_name label path termux_prefix termux_home canonicalize_path
tudo_expand_termux_path() {

	local return_value

	#if parameter count is not 6
	if [ $# -ne 6 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_expand_termux_path\""
		return 1
	fi

	local variable_name="$1"
	local label="$2"
	local path_to_expand="$3"
	local termux_prefix="$4"
	local termux_home="$5"
	local canonicalize_path="$6"

	[[ "$path_to_expand" == "\$PREFIX/" ]] && path_to_expand="$termux_prefix" #replace '$PREFIX/' with "$termux_prefix"
	[[ "$path_to_expand" == "~/" ]] && path_to_expand="$termux_home" #replace '~/' with "$termux_home"

	path_to_expand=${path_to_expand/#\$PREFIX\//$termux_prefix\/} #replace '$PREFIX/*' with "$termux_prefix/*"
	path_to_expand=${path_to_expand/#~\//$termux_home\/} #replace '~/*' with "$termux_home/*"

	#if canonicalize_path equals "1" or (canonicalize_path equals "2" and path_to_expand is not a symlink
	if [[ "$canonicalize_path" == "1" ]] || ([[ "$canonicalize_path" == "2" ]] && [ ! -L "$path_to_expand" ]); then
		path_to_expand="$(readlink -m -- "$path_to_expand")"
	fi

	local valid_bash_variable_name_regex='^[a-zA-Z][a-zA-Z0-9_]*(\[[0-9]+\])?$'

	#if variable_name does not equal "path_to_expand" and is valid bash variable_name
	if [[ "$variable_name" != "path_to_expand" ]] && [[ "$variable_name" =~ $valid_bash_variable_name_regex ]]; then
		#set variable_name to path_to_expand
		printf -v "$variable_name" "%s" "$path_to_expand"
	else
		tudo_log_errors "variable_name \"$1\" passed to \"tudo_expand_termux_path\" equals \"path_to_expand\" or is not a valid bash variable name"
		return 1
	fi

}

#the path will be first expanded
#if the path is an absolute path and an executable then that is returned, otherwise function fails with 112
#if the path is not an absolute path, then it is searched in current working directory by "readlink -m" and also in all the paths in paths_to_check_for_executable list (ideally $PATH variable)
#if an executable is found, then that is returned, otherwise function fails with 112
#tudo_find_absolute_path_for_executable_and_validate variable_name label path paths_to_check_for_executable termux_prefix termux_home
tudo_find_absolute_path_for_executable_and_validate() {

	local return_value

	#if parameter count is not 6
	if [ $# -ne 6 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_find_absolute_path_for_executable_and_validate\""
		return 1
	fi

	local variable_name="$1"
	local label="$2"
	local path="$3"
	local paths_to_check_for_executable="$4"
	local termux_prefix="$5"
	local termux_home="$6"

	local executable_found=0
	local absolute_path

	#replace "$PREFIX/" or "~/" prefix with termux absolute paths in path
	tudo_expand_termux_path "absolute_path" "${label}_PATH" "$path" "$termux_prefix" "$termux_home" 2
	return_value=$?
	if [ $return_value -ne 0 ]; then
		tudo_log_errors "Failed to expand ${label}_PATH \"$path\""
		return $return_value
	fi

	tudo_log 2 "${label}_ABSOLUTE_PATH=\"$absolute_path\""

	test -f "$absolute_path" && test -r "$absolute_path" && test -x "$absolute_path"
	return_value=$?
	if [ $return_value -ne 0 ] && [ $return_value -ne 1 ]; then
		tudo_log_errors "Failed to run the following test types on the file \"${label}_PATH\" at path \"$absolute_path\": [regular file], [readable], [executable]"
		return $return_value
	elif [ $return_value -eq 0 ]; then
		tudo_log 2 "Executable found at \"$absolute_path\""
		executable_found=1
	fi

	#if executable still not found and original path was not an absolute path, then check if path exists in PATH_TO_EXPORT
	local valid_absolute_path_regex='^(/[^/]+)+$'
	if [[ "$executable_found" == "0" ]] && [[ ! "$path" =~ $valid_absolute_path_regex ]]; then
		#check if paths_to_check_for_executable is valid
		local invalid_value_for_path_variable_regex='^:|:$|.*::.*|.*'$'\n''.*'
		if [[ "$paths_to_check_for_executable" =~ $invalid_value_for_path_variable_regex ]]; then
			tudo_log_errors "PATHS_TO_CHECK_FOR_EXECUTABLE \"$paths_to_check_for_executable\" is invalid, it cannot start or end with a colon, contain two consecutive colons \":\" or contain newline characters"
			return 1
		fi

		tudo_log 2 "Checking for \"$path\" executable at following paths: \"$paths_to_check_for_executable\""

		#check if path is a binary or any executable in paths_to_check_for_executable
		for path_to_check_for_executable in ${paths_to_check_for_executable//:/ }; do
			absolute_path="$path_to_check_for_executable/$path"
			tudo_log 2 "\"$absolute_path\""

			test -f "$absolute_path" && test -r "$absolute_path" && test -x "$absolute_path"
			return_value=$?
			if [ $return_value -ne 0 ] && [ $return_value -ne 1 ]; then
				tudo_log_errors "Failed to run the following test types on the file \"${label}_PATH\" at path \"$absolute_path\": [regular file], [readable], [executable]"
				return $return_value
			elif [ $return_value -eq 0 ]; then
				tudo_log 2 "Executable found at \"$absolute_path\""
				executable_found=1
				break
			fi
		done
	fi

	#if executable is not found, then exit with error
	#since this is the final path
	if [[ "$executable_found" != "1" ]]; then
		return 112
	fi

	local valid_bash_variable_name_regex='^[a-zA-Z][a-zA-Z0-9_]*(\[[0-9]+\])?$'

	#if variable_name does not equal "absolute_path" and is valid bash variable_name
	if [[ "$variable_name" != "absolute_path" ]] && [[ "$variable_name" =~ $valid_bash_variable_name_regex ]]; then
		#set variable_name to absolute_path
		printf -v "$variable_name" "%s" "$absolute_path"
	else
		tudo_log_errors "variable_name \"$1\" passed to \"tudo_find_absolute_path_for_executable_and_validate\" equals \"absolute_path\" or is not a valid bash variable name"
		return 1
	fi

}

#validate if path is under TERMUX_FILES and is not backlisted
#tudo_validate_path_is_a_whitelisted_path_under_termux_files label path
tudo_validate_path_is_a_whitelisted_path_under_termux_files() {

	local return_value

	#if parameter count is not 2
	if [ $# -ne 2 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_validate_path_is_a_whitelisted_path_under_termux_files\""
		return 1
	fi

	local label="$1"
	local path="$2"

	local valid_path_under_termux_files_regex='^'"$TERMUX_FILES"'/.+'
	local blacklisted_path_in_termux_files_regex='^'"$TERMUX_FILES"'[\/]+(('"$TERMUX_HOME_BASENAME"'[\/]+\.(cache|config|local|termux))|('"$TERMUX_PREFIX_BASENAME"')|('"$TERMUX_PREFIX_BASENAME"'[\/]+.*))([\/]+)?$'

	#if path same as TERMUX_FILES
	if [[ "$path" == "$TERMUX_FILES" ]]; then
		tudo_log 2 "$label \"$path\" is the same as TERMUX_FILES"
		return 2
	#if path is set to an absolute path under TERMUX_FILES
	elif [[ "$path" =~ $valid_path_under_termux_files_regex ]]; then
		#if path is set to a blacklist path under TERMUX_FILES
		if [[ "$path" =~ $blacklisted_path_in_termux_files_regex ]]; then
			tudo_log 2 "$label \"$path\" matches one of following blacklisted paths:"
			tudo_log 2 "\"$TERMUX_HOME/.{cache,config,local,termux}\", \"$TERMUX_PREFIX/*\""
			return 2
		else
			return 0
		fi
	else
		return 3
	fi

}

#tudo_parse_and_validate_path_variable variable_name label path remove_duplicates
tudo_parse_and_validate_path_variable() {

	local return_value

	#if parameter count is not 4
	if [ $# -ne 4 ]; then
		tudo_log_errors "Invalid parameter count to \"tudo_parse_and_validate_path_variable\""
		return 1
	fi

	local variable_name="$1"
	local label="$2"
	local path_to_parse="$3"
	local remove_duplicates="$4"

	#if remove_duplicates is enabled
	if [[ "$remove_duplicates" == "1" ]]; then
		#remove duplicates from path_to_parse
		path_to_parse="$(printf "%s" "$path_to_parse" | awk -v RS=: -v ORS= '!a[$0]++ {if (NR>1) printf(":"); printf("%s", $0) }' )"
		return_value=$?
		if [ $return_value -ne 0 ]; then
			tudo_log_errors "Failed to remove duplicates from $label \"$path_to_parse\""
			return $return_value
		fi
	fi

	#check if path_to_parse is valid
	local invalid_value_for_path_variable_regex='^:|:$|.*::.*|.*'$'\n''.*'
	if [[ "$path_to_parse" =~ $invalid_value_for_path_variable_regex ]]; then
		tudo_log_errors "$label \"$path_to_parse\" is invalid, it cannot start or end with a colon, contain two consecutive colons \":\" or contain newline characters"
		return 1
	fi

	local valid_bash_variable_name_regex='^[a-zA-Z][a-zA-Z0-9_]*(\[[0-9]+\])?$'

	#if variable_name does not equal "path_to_parse" and is valid bash variable_name
	if [[ "$variable_name" != "path_to_parse" ]] && [[ "$variable_name" =~ $valid_bash_variable_name_regex ]]; then
		#set variable_name to path
		printf -v "$variable_name" "%s" "$path_to_parse"
	else
		tudo_log_errors "variable_name \"$1\" passed to \"tudo_parse_and_validate_path_variable\" equals \"path_to_parse\" or is not a valid bash variable name"
		return 1
	fi

}

#tudo_replace_comma_alternative_chars_with_commas_in_string string
tudo_replace_comma_alternative_chars_with_commas_in_string() {

	local valid_bash_variable_name_regex='^[a-zA-Z][a-zA-Z0-9_]*(\[[0-9]+\])?$'

	#if $1 is valid bash variable_name
	if [[ "$1" =~ $valid_bash_variable_name_regex ]]; then
		#set variable_name stored in $1 to variable_value in $2 after replacing all COMMA_ALTERNATIVE characters with a comma ',' in $2
		printf -v "$1" "%s" "${2//$COMMA_ALTERNATIVE/,}"
	else
		tudo_log_errors "variable_name \"$1\" passed to \"tudo_replace_comma_alternative_chars_with_commas_in_string\" is not a valid bash variable name"
	fi

}

#tudo_trim_trailing_newlines variable_name variable_value
tudo_trim_trailing_newlines() {

	local extglob_was_unset=1
	shopt extglob >/dev/null && extglob_was_unset=0 #check if 'extglob' is currently set
	(( extglob_was_unset )) && shopt -s extglob #set 'extglob', if currently unset

	local valid_bash_variable_name_regex='^[a-zA-Z][a-zA-Z0-9_]*(\[[0-9]+\])?$'

	#if $1 is valid bash variable_name
	if [[ "$1" =~ $valid_bash_variable_name_regex ]]; then
		#set variable_name stored in $1 to variable_value in $2 without trailing newline and carriage return characters
		printf -v "$1" "%s" "${2%%*([$'\r\n'])}"
	else
		tudo_log_errors "variable_name \"$1\" passed to \"tudo_trim_trailing_newlines\" is not a valid bash variable name"
	fi

	(( extglob_was_unset )) && shopt -u extglob #unset 'extglob', if previously unset

}

process_tudo_parameters() {

	#parse options to tudo command
	while getopts ":hvabBcdeEfFHilLnNoOpPrsS-:" opt; do
		case ${opt} in
			-)
				long_optargs="${OPTARG#*=}"
				case "${OPTARG}" in
					help-extra)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						show_tudo_help_extra
						$tudo_exit_command 0
						;;
					help-extra*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					help)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						show_tudo_help
						$tudo_exit_command 0
						;;
					help*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					version)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						echo "$version"
						$tudo_exit_command 0
						;;
					version*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					comma-alternative=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						COMMA_ALTERNATIVE="$val"
						;;
					comma-alternative | comma-alternative=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					dry-run)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						dry_run_tudo=1
						;;
					dry-run*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					export-paths=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						tudo_trim_trailing_newlines "ADDITIONAL_PATHS_TO_EXPORT" "$val"
						;;
					export-paths | export-paths=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					export-ld-lib-paths=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						tudo_trim_trailing_newlines "ADDITIONAL_LD_LIBRARY_PATHS_TO_EXPORT" "$val"
						;;
					export-ld-lib-paths | export-ld-lib-paths=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					hold)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						HOLD_STRING_AFTER_TUDO=""
						hold_after_tudo=1
						;;
					hold=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						tudo_trim_trailing_newlines "HOLD_STRING_AFTER_TUDO" "$val"
						hold_after_tudo=1
						;;
					hold=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					hold-if-fail)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						hold_only_on_failure=1
						;;
					hold-if-fail*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					list-interactive-shells)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						echo "$TUDO_SUPPORTED_INTERACTIVE_SHELLS"
						$tudo_exit_command 0
						;;
					list-interactive-shells*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					list-script-shells)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						echo "$TUDO_SUPPORTED_SCRIPT_SHELLS"
						$tudo_exit_command 0
						;;
					list-script-shells*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					no-create-hist)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						tudo_shells_automatically_create_history_files=0
						;;
					no-create-hist*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					no-create-rc)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						tudo_shells_automatically_create_rc_files=0
						;;
					no-create-rc*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					no-hist)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						tudo_shells_history_enabled=0
						;;
					no-hist*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					no-log-args)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						disable_arguments_logging=1
						;;
					no-log-args*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					keep-temp)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						do_not_delete_tudo_temp_directory_on_exit=1
						;;
					keep-temp*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					post-shell=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						tudo_trim_trailing_newlines "TUDO_POST_SHELL" "$val"
						;;
					post-shell | post-shell=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					post-shell-home=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						tudo_trim_trailing_newlines "TUDO_POST_SHELL_HOME" "$val"
						custom_tudo_post_shell_home_set=1
						;;
					post-shell-home | post-shell-home=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					post-shell-options=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						IFS=$'\n' val_arr=( $(xargs -r -n1 -- printf -- "%s\n" <<<"$val") )
						IFS=$' \t\n'
						TUDO_POST_SHELL_INTERACTIVE_ADDITIONAL_COMMAND_OPTIONS=( "${val_arr[@]}" )
						;;
					post-shell-options | post-shell-options=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					post-shell-post-commands=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						ADDITIONAL_TUDO_POST_SHELL_POST_COMMANDS_TO_RUN="$val"
						;;
					post-shell-post-commands | post-shell-post-commands=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					post-shell-pre-commands=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						ADDITIONAL_TUDO_POST_SHELL_PRE_COMMANDS_TO_RUN="$val"
						;;
					post-shell-pre-commands | post-shell-pre-commands=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					post-shell-stdin-string=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						TUDO_POST_SHELL_STDIN_STRING="$val"
						;;
					post-shell-stdin-string | post-shell-stdin-string=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					remove-prev-temp)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						remove_previous_tudo_temp_files=1
						;;
					remove-prev-temp*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					script-decode)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						force_use_temp_script_file_for_core_script=1
						decode_core_script_content=1
						;;
					script-decode*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					script-name=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						tudo_trim_trailing_newlines "TUDO_CORE_SCRIPT_TEMP_FILENAME" "$val"
						;;
					script-name | script-name=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					script-redirect=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						tudo_trim_trailing_newlines "TUDO_CORE_SCRIPT_REDIRECT_MODE" "$val"
						;;
					script-redirect | script-redirect=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					shell=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						tudo_trim_trailing_newlines "TUDO_SHELL" "$val"
						;;
					shell | shell=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					shell-home=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						tudo_trim_trailing_newlines "TUDO_SHELL_HOME" "$val"
						custom_tudo_shell_home_set=1
						;;
					shell-home | shell-home=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					shell-options=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						IFS=$'\n' val_arr=( $(xargs -r -n1 -- printf -- "%s\n" <<<"$val") )
						IFS=$' \t\n'
						TUDO_SHELL_ADDITIONAL_COMMAND_OPTIONS=( "${val_arr[@]}" )
						;;
					shell-options | shell-options=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					shell-post-commands=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						ADDITIONAL_TUDO_SHELL_POST_COMMANDS_TO_RUN="$val"
						;;
					shell-post-commands | shell-post-commands=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					shell-pre-commands=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						ADDITIONAL_TUDO_SHELL_PRE_COMMANDS_TO_RUN="$val"
						;;
					shell-pre-commands | shell-pre-commands=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					shell-stdin-string=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						TUDO_SHELL_STDIN_STRING="$val"
						;;
					shell-stdin-string | shell-stdin-string=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					sleep=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						tudo_trim_trailing_newlines "SLEEP_TIME_AFTER_TUDO" "$val"
						sleep_after_tudo=1
						;;
					sleep | sleep=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					sleep-if-fail)
						tudo_log_args "Parsing option: '--${OPTARG%=*}'"
						sleep_only_on_failure=1
						;;
					sleep-if-fail*)
						tudo_log_arg_errors "Invalid option or parameters not allowed for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					title=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						tudo_trim_trailing_newlines "TUDO_SHELL_TERMINAL_TITLE" "$val"
						set_tudo_shell_terminal_title=1
						;;
					title | title=)
						TUDO_SHELL_TERMINAL_TITLE=""
						set_tudo_shell_terminal_title=1
						;;
					work-dir=?*)
						val="$long_optargs"
						tudo_log_args "Parsing option: '--${OPTARG%=*}', value: '${val}'"
						#if parse_commands_as_per_run_command_intent_rules is enabled
						if  [[ "$parse_commands_as_per_run_command_intent_rules" == "1" ]]; then
							tudo_replace_comma_alternative_chars_with_commas_in_string "val" "$val"
						fi
						tudo_trim_trailing_newlines "TUDO_SHELL_WORKING_DIR" "$val"
						;;
					work-dir | work-dir=)
						tudo_log_arg_errors "No parameters set for option: '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
					'' ) #"--" terminates argument processing to support non-options that start with dashes
						tudo_log_args "Parsing option: '--'"
						break
						;;
					*)
						tudo_log_arg_errors "Unknown option '--${OPTARG%=*}'"
						exit_tudo_on_error
						;;
				esac
				;;
			h)
				tudo_log_args "Parsing option: '-${opt}'"
				show_tudo_help
				$tudo_exit_command 0
				;;
			v)
				tudo_log_args "Parsing option: '-${opt}'"
				if [ "$tudo_verbose_level" -lt "2" ]; then
					tudo_verbose_level=$((tudo_verbose_level+1));
				else
					tudo_log_arg_errors "Invalid Option, max verbose level is 2"
					exit_tudo_on_error
				fi
				;;
			a)
				tudo_log_args "Parsing option: '-${opt}'"
				force_set_priority_to_android_paths=1
				;;
			b)
				tudo_log_args "Parsing option: '-${opt}'"
				go_back_to_last_activity_after_running_core_script=1
				;;
			B)
				tudo_log_args "Parsing option: '-${opt}'"
				run_core_script_in_background=1
				;;
			c)
				tudo_log_args "Parsing option: '-${opt}'"
				clear_shell_after_running_core_script=1
				;;
			d)
				tudo_log_args "Parsing option: '-${opt}'"
				disable_stdin_for_core_script=1
				;;
			e)
				tudo_log_args "Parsing option: '-${opt}'"
				exit_early_if_core_script_fails=1
				;;
			E)
				tudo_log_args "Parsing option: '-${opt}'"
				exec_tudo_shell=1
				;;
			f)
				tudo_log_args "Parsing option: '-${opt}'"
				force_use_temp_script_file_for_core_script=1
				;;
			F)
				tudo_log_args "Parsing option: '-${opt}'"
				core_script_is_path_to_script_file=1
				;;
			H)
				tudo_log_args "Parsing option: '-${opt}'"
				same_tudo_post_shell_home_as_tudo_shell_home=1
				;;
			i)
				tudo_log_args "Parsing option: '-${opt}'"
				run_interactive_post_tudo_shell_after_running_core_script=1
				;;
			l)
				tudo_log_args "Parsing option: '-${opt}'"
				go_to_launcher_activity_after_running_core_script=1
				;;
			L)
				tudo_log_args "Parsing option: '-${opt}'"
				export_all_existing_paths_in_ld_library_path_variable=1
				;;
			n)
				tudo_log_args "Parsing option: '-${opt}'"
				TUDO_CORE_SCRIPT_REDIRECT_MODE=3
				;;
			N)
				tudo_log_args "Parsing option: '-${opt}'"
				TUDO_CORE_SCRIPT_REDIRECT_MODE=4
				;;
			o)
				tudo_log_args "Parsing option: '-${opt}'"
				TUDO_CORE_SCRIPT_REDIRECT_MODE=0
				;;
			O)
				tudo_log_args "Parsing option: '-${opt}'"
				TUDO_CORE_SCRIPT_REDIRECT_MODE=1
				;;
			p)
				tudo_log_args "Parsing option: '-${opt}'"
				command_type="path"
				command_type_path_forced=1
				;;
			P)
				tudo_log_args "Parsing option: '-${opt}'"
				export_all_existing_paths_in_path_variable=1
				;;
			r)
				tudo_log_args "Parsing option: '-${opt}'"
				parse_commands_as_per_run_command_intent_rules=1
				;;
			s)
				tudo_log_args "Parsing option: '-${opt}'"
				command_type="script"
				;;
			S)
				tudo_log_args "Parsing option: '-${opt}'"
				same_tudo_post_shell_as_tudo_shell=1
				;;
			\?)
				tudo_log_arg_errors "Unknown option: '-${OPTARG}'"
				exit_tudo_on_error
				;;
		esac
	done
	shift $((OPTIND -1)) #remove already processed arguments from argument list

	#if arguments received
	if [ $# -ne 0 ]; then
		#if (command_type_path_forced is not enabled and $1 equals "su" or "asu"
		if [[ "$command_type_path_forced" != "1" ]] && ([[ "$1" == "su" ]] || [[ "$1" == "asu" ]]); then
			command_type="$1"
			shift #remove $1 from the argument list

			#if more arguments are given
			if [ $# -ne 0 ]; then
				tudo_log_arg_errors "Unknown arguments to \"$command_type\": '$*'"
				exit_tudo_on_error
			fi
		#if command_type equals "path" or "script"
		elif [[ "$command_type" == "path" ]] || [[ "$command_type" == "script" ]]; then
			#set rest of the arguments to the tudo script as TUDO_COMMAND
			TUDO_COMMAND=()
			local return_value
			local read_argument_from_fd
			local fd_number
			local i=1
			for arg in "$@"; do
				read_argument_from_fd=0

				#if process substitution was used to pass path to an fd file as argument that contains the actual argument value
				#and the fd is not of stdin, stdout or stderr
				if [[ "$arg" =~ ^/proc/self/fd/[0-9]+$ ]] && [[ ! "$arg" =~ ^/proc/self/fd/(0|1|2)$ ]]; then
					fd_number="${arg##*/}"
					#if fd is readable, then
					if read -t 0 -u "$fd_number" 2>/dev/null; then
						#enable read_argument_from_fd
						read_argument_from_fd=1

						#if command_type equals "script" and its the first argument
						if [[ "$command_type" == "script" ]] && [ $i -eq 1 ]; then
							#disable read_argument_from_fd since we are reading it here with cat
							#fd can't be read again, seeking backwards is not possible
							read_argument_from_fd=0

							#read core_script from fd in encoded form since it may contain non UTF-8 or binary data
							encoded_arg="$(cat "$arg" | base64)"
							return_value=$?
							if [ $return_value -ne 0 ] && [ $return_value -ne 1 ]; then
								tudo_log_arg_errors "Failure while encoding core_script received as argument"
								$tudo_exit_command $return_value
							fi

							#check if core_script contains non UTF-8 or binary data
							#decode data first before passing to grep
							printf '%s' "$encoded_arg" | base64 -d | grep -axvq '.*'
							return_value=$?
							if [ $return_value -ne 0 ] && [ $return_value -ne 1 ]; then
								tudo_log_arg_errors "Failure while checking if core_script contains non UTF-8 or binary data"
								$tudo_exit_command $return_value
							#if found
							elif [ $return_value -eq 0 ]; then
								#enable use of temp script file for core_script and enable decoding
								force_use_temp_script_file_for_core_script=1
								decode_core_script_content=1

								#set encoded data to arg
								arg="$encoded_arg"
							#if not found
							else
								#set decoded data to arg
								arg="$(printf '%s' "$encoded_arg" | base64 -d)"
							fi
						fi
					fi
				fi

				#if read_argument_from_fd is enabled
				if [[ "$read_argument_from_fd" == "1" ]]; then
					#use the fd file content as argument value
					TUDO_COMMAND+=( "$(<"$arg")" )
				else
					#directly use the argument value
					TUDO_COMMAND+=("$arg")
				fi

				i=$((i + 1))
			done
			shift $# #remove all remaining arguments from argument list
		fi
	#else show help
	else
		if [[ "$command_type" == "script" ]]; then
			TUDO_COMMAND=()
		else
			show_tudo_help
			$tudo_exit_command 0
		fi
	fi

}

show_tudo_help() {

	cat <<'TUDO_HELP_EOF'

tudo is a wrapper script to drop to the supported shells or execute
shell script files or their text passed as an argument with termux
user context in termux.


Usage:
  tudo [command_options] su
  tudo [command_options] asu
  tudo [command_options] [-p] <command> [command_args]
  tudo [command_options] -s <core_script> [core_script_args]


Available command_options:
  [ -h | --help ]    display this help screen
  [ --help-extra ]   display more help about how tudo command works
  [ --version ]      display version
  [ -v | -vv ]       set verbose level to 1 or 2
  [ -a ]             force set priority to android paths for path
                     command type
  [ -b ]             go back to last activity after running core_script
  [ -B ]             run core_script in background
  [ -c ]             clear shell after running core_script
  [ -d ]             disable stdin for core_script
  [ -e ]             exit early if core_script fails
  [ -E ]             exec interactive shell or the path command
  [ -f ]             force use temp script file for core_script
  [ -F ]             consider core_script to be a path to script file
                     instead of script text
  [ -H ]             same tudo post shell home as tudo shell home
  [ -i ]             run interactive tudo post shell after running
                     core_script
  [ -l ]             go to launcher activtiy after running core_script
  [ -L ]             export all existing paths in '$LD_LIBRARY_PATH'
                     variable
  [ -n ]             redirect stderr to /dev/null for core_script
  [ -N ]             redirect stdout and stderr to /dev/null for
                     core_script
  [ -o ]             redirect stderr to stdout for core_script
  [ -O ]             redirect stdout to stderr for core_script
  [ -p ]             set 'path' as command type [default]
  [ -P ]             export all existing paths in '$PATH' variable
  [ -r ]             parse commands as per RUN_COMMAND intent rules
  [ -s ]             set 'script' as command type
  [ -S ]             same tudo post shell as tudo shell
  [ --comma-alternative=<alternative> ]
                     comma alternative character to be used for
                     the `-r` option instead of the default
  [ --dry-run ]
                     do not execute tudo commands
  [ --export-paths=<paths> ]
                     additional paths to export in PATH variable,
                     separated with colons ':'
  [ --export-ld-lib-paths=<paths> ]
                     additional paths to export in LD_LIBRARY_PATH
                     variable, separated with colons ':'
  [ --hold[=<string>] ]
                     hold tudo from exiting until string is entered,
                     defaults to any character if string is not passed
  [ --hold-if-fail ]
                     if '--hold' option is passed, then only hold if
                     exit code of tudo does not equal '0'
  [ --list-interactive-shells ]
                     display list of supported interactive shells
  [ --list-script-shells ]
                     display list of supported script shells
  [ --no-create-rc ]
                     do not create rc files automatically
  [ --no-create-hist ]
                     do not create history files automatically
  [ --no-hist ]
                     do not save history for tudo shell and tudo post
                     shell
  [ --no-log-args ]
                     do not log arguments and core_script content
                     when verbose mode is enabled
  [ --keep-temp ]
                     do not delete tudo temp directory on exit
  [ --post-shell=<shell> ]
                     name or absolute path for tudo post shell
  [ --post-shell-home=<path> ]
                     absolute path for tudo post shell home
  [ --post-shell-options=<options> ]
                     additional options to pass to tudo post shell
  [ --post-shell-post-commands=<commands> ]
                     bash commands to run after tudo post shell
  [ --post-shell-pre-commands=<commands> ]
                     bash commands to run before tudo post shell
  [ --post-shell-stdin-string=<string> ]
                     string to pass as stdin to tudo post shell
  [ --remove-prev-temp ]
                     remove temp files and directories created on
                     previous runs of tudo command
  [ --script-decode ]
                     consider the core_script as base64
                     encoded that should be decoded before execution
  [ --script-name=<name> ]
                     filename to use for the core_script temp file
                     created in '.tudo.temp.XXXXXX' directory instead
                     of 'tudo_core_script'
  [ --script-redirect=<mode/string> ]
                     core_script redirect mode for stdout and stderr
  [ --shell=<shell> ]
                     name or absolute path for tudo shell
  [ --shell-home=<path> ]
                     absolute path for tudo shell home
  [ --shell-options=<options> ]
                     additional options to pass to tudo shell
  [ --shell-post-commands=<commands> ]
                     bash commands to run after tudo shell for script
                     command type
  [ --shell-pre-commands=<commands> ]
                     bash commands to run before tudo shell
  [ --shell-stdin-string=<string> ]
                     string to pass as stdin to tudo shell for script
                     command type
  [ --sleep=<seconds> ]
                     sleep for x seconds before exiting tudo
  [ --sleep-if-fail ]
                     if '--sleep' option is passed, then only sleep if
                     exit code of tudo does not equal '0'
  [ --title=<title> ]
                     title for tudo shell terminal
  [ --work-dir=<path> ]
                     absolute path for working directory


Set verbose level to 1 or 2 to get more info when running tudo command.

Pass '--dry-run' option with verbose mode enabled to see the commands
that will be run without actually executing them.

Visit https://github.com/agnostic-apollo/tudo for more help on how
tudo command works.
TUDO_HELP_EOF

echo $'\n'"Supported interactive shells: \`$TUDO_SUPPORTED_INTERACTIVE_SHELLS\`"
echo $'\n'"Supported script shells: \`$TUDO_SUPPORTED_SCRIPT_SHELLS\`"

}

show_tudo_help_extra() {

	show_tudo_help

	cat <<'TUDO_HELP_EOF'


The 'su' command type drops to a termux user interactive
shell for any of the supported interactive shells. To drop to a
'bash' shell, just run 'tudo su'. The priority will be set to termux
bin and library paths in '$PATH' and '$LD_LIBRARY_PATH' variables.
Use the '--shell' option to set the interactive shell to use.


The 'asu' command type is the same as 'su' command type but
instead the priority will be set to android bin and library paths in
'$PATH' and '$LD_LIBRARY_PATH' variables.
Use the '--shell' option to set the interactive shell to use.


The 'path' command type runs a single command in termux user
context. You can use it just by running 'tudo <command> [command_args]'
where 'command' is the executable you want to run and 'command_args'
are any optional arguments to it. The 'command' will be run within a
'bash' shell. Priority is given to termux bin and library paths unless
'command' exists in '/system' partition.


The 'script' command type takes any script text or path to a script
file for any of the supported script shells referred as 'tudo shell',
and executes the script with any optional arguments with the desired
script shell. This can be done by running the
'tudo -s <core_script> [core_script_args]' command.
The 'core_script' will be considered a 'bash' script by default.
The 'core_script' will be passed to the desired shell using
process substitution or after storing the 'core_script' in a temp file
in a temp directory in 'tudo shell' home
'$TMPDIR/.tudo.temp.XXXXXX/tudo_core_script' and passing the path to
the desired shell, where 'XXXXXX' is a randomly generated string.
The method is automatically chosen based on the script shell
capabilities. The '-f' option can be used to force the usage of a
script file. The '-F' option can passed so that the 'core_script'
is considered as a path to script file that should be passed to
'tudo shell' directly instead of considering it as a script text.
Use the '--shell' option to set the script shell to use.
Use the '--post-shell' option to set the interactive shell to use if
'-i' option is passed.


Run "exit" command of your shell to exit interactive shells and return
to the termux shell.
TUDO_HELP_EOF

}

exit_tudo_on_error() {

	show_tudo_help
	tudo_run_pre_exit_commands 1
	$tudo_exit_command 1

}

#call tudo_main function
[[ x"${BASH_SOURCE[0]}" == x"$0" ]] && tudo_main "$@"; $tudo_exit_command 0;
